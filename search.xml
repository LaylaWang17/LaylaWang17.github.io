<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue项目配置Jest踩坑记</title>
    <url>/2020/03/13/Vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEJest%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<p>本文总结了在 Vue 项目中引入 Jest 测试的相关方法。</p>
<a id="more"></a>

<ul>
<li><p>前提：项目已经有基础的 Webpack、Babel 等配置，比如使用 Vue-CLI 创建的项目</p>
</li>
<li><p>安装 Jest 和 Vue Test Utils</p>
<p>其中，Vue Test Utils 是 Vue.js 官方的单元测试工具库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev jest @vue/<span class="built_in">test</span>-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>package.json</code> 中定义运行单元测试的脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "jest"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为单文件 Vue 组件<code>*.vue</code>配置处理器</p>
<p>安装 <code>vue-jest</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev vue-jest</span><br></pre></td></tr></table></figure>

<p>在<code>package.json</code> 中增加 Jest 相关配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "moduleFileExtensions": [</span><br><span class="line">    "js",</span><br><span class="line">    "json",</span><br><span class="line">    <span class="comment">// 告诉 Jest 处理 `*.vue` 文件</span></span><br><span class="line">    <span class="string">"vue"</span></span><br><span class="line">  ],</span><br><span class="line">  "transform": &#123;</span><br><span class="line">    <span class="comment">// 用 `vue-jest` 处理 `*.vue` 文件</span></span><br><span class="line">    ".*\\.(vue)$": "vue-jest"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或创建单独的 Jest 配置文件<code>jest.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  moduleFileExtensions: [<span class="string">"js"</span>, <span class="string">"json"</span>, <span class="string">"vue"</span>],</span><br><span class="line">  transform: &#123;</span><br><span class="line">    <span class="string">".*\\.(vue)$"</span>: <span class="string">"vue-jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为 Jest 配置 Babel</p>
<p>安装 <code>babel-jest</code>可以帮助你在测试中使用 ES modules 语法和 stage-x 的特性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-jest</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果运行测试时提示<code>Cannot find module &#39;babel-core&#39;</code>，则需要额外安装<code>babel-core@^7.0.0-bridge.0</code>（安装<code>babel-core@^7.0.0-bridge.0</code>是因为由于 Babel 7 将以<code>@babel/core</code>而不是<code>babel-core</code>的形式发布，<a href="https://github.com/babel/babel-bridge" target="_blank" rel="noopener">babel-bridge</a>是 Babel 官方提供的过渡库）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-core@^7.0.0-bridge.0</span><br></pre></td></tr></table></figure>

<p>给 Jest 配置中增加 JavaScript 文件的<code>transform</code>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">transform: &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"^.+\\.js$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 webpack 使用了 <code>babel-preset-env</code>，这时默认的 Babel 配置会关闭 ES modules 的转译，因为 webpack 已经可以处理 ES modules 了。然而，我们还是需要为我们的测试而开启它，因为 Jest 的测试用例会直接运行在 Node 上。同样的，我们可以告诉 <code>babel-preset-env</code> 面向我们使用的 Node 版本。这样做会跳过转译不必要的特性使得测试启动更快。为了仅在测试时应用这些选项，可以把它们放到一个独立的 <code>env.test</code> 配置项中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">"@vue/cli-plugin-babel/preset"</span>],</span><br><span class="line">  env: &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      presets: [[<span class="string">"@babel/preset-env"</span>, &#123; <span class="attr">targets</span>: &#123; <span class="attr">node</span>: <span class="string">"current"</span> &#125; &#125;]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果项目中使用了第三方组件库，如 Element-UI，则需要给 Jest 增加额外的配置以 mock 掉样式文件</p>
<p>安装<code>identity-obj-proxy</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm instal --save-dev identity-obj-proxy</span><br></pre></td></tr></table></figure>

<p>给 Jest 配置增加<code>moduleNameMapper</code>配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">moduleNameMapper: &#123;</span><br><span class="line">  <span class="string">"\\.(css|less)$"</span>: <span class="string">"identity-obj-proxy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html" target="_blank" rel="noopener">用 Jest 测试单文件组件</a></li>
<li><a href="https://jestjs.io/docs/en/getting-started#using-babel" target="_blank" rel="noopener">Jest - Docs - Using Babel</a></li>
<li><a href="https://jestjs.io/docs/en/webpack#mocking-css-modules" target="_blank" rel="noopener">Jest - Docs - Mocking CSS Modules</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Vuex的基本使用</title>
    <url>/2020/03/11/Vuex%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在我们使用 Vue 搭建的 App 里，当访问数据对象时，一个组件实例只是简单的代理访问。当 App 结构复杂、组件较多时，如果有一处需要被多个实例共享的状态，可以简单的通过维护一份数据来实现共享，这就促成了我们对状态管理机制对需要，比如 Vuex。</p>
<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Vuex 是基于 Flux 架构的状态管理库。可以参考 <a href="https://laylawang17.github.io/2020/03/10/%E7%90%86%E8%A7%A3Flux/">理解 Flux</a> 这篇文章先做一些基础对了解。Vuex 的核心思想就是<strong>store 模式</strong>，即：将需要共享的状态放在在 store 自身的 action 中管理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = &#123;</span><br><span class="line">  state: &#123;...&#125;,</span><br><span class="line">  action: &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>则组件实例的 state 可以包含共享状态和私有状态两类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    privateState: &#123;&#125;,</span><br><span class="line">    sharedState: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>store 和组件的关系如下图</p>
<img src="http://ww1.sinaimg.cn/large/98792392ly1gconn3v15sj20xc0xcjrg.jpg" style="zoom:40%;" />

<p>对于小型应用来说，我们使用简单的 store 模式就足以让我们的 App 内部变得简单明了，但是对于大型应用借助 Vuex 可能是更好的选择。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><strong>Store</strong>：store 用来管理状态，包括数据和各种方法，由 state、getters、mutations、actions、plugins 组成</li>
<li><strong>State</strong>：state 中定义了组件所有的状态</li>
<li><strong>Getter</strong>：getter 可以看作是由 state 派生的“计算属性”</li>
<li><strong>Mutations</strong>：包含真正实现 state 更新的业务逻辑</li>
<li><strong>Action</strong>：定义更新 state 的动作，用于知会 mutation 何时处理变更</li>
</ul>
<p>在使用 Vuex 的 App 中，当用户与 App 交互时发生的事情包括：</p>
<ul>
<li>启动 App 时，View 从 store 中获取所需的 state（以及 getters）</li>
<li>用户进行输入、点击等操作时，View 发送（dispatch）相应的 action 给 store，action 中包含了操作类型及数据</li>
<li>action 会提交（commit）对应的 mutation</li>
<li>mutation 中完成真正的业务逻辑并更新 state</li>
<li>View 监听 state 的变化并重新渲染</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>创建 store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  plugins</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以简单的计数 App 为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 注册mutation</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从根组件注入 store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(vuex);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  component: &#123;...&#125;,</span><br><span class="line">  template: ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>在子组件中作为一个计算属性获取 state</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简单的方法是使用 Vuex 提供的<code>mapState()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([<span class="string">'count'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>computed</code>对象里还可以有组件私有的其他计算属性。</p>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>如 Todo List App 可能需要获得状态为 active 的 todo 列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [...]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    activeTodos: <span class="function"><span class="params">state</span> =&gt;</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.active)，</span><br><span class="line">    <span class="comment">// 接收其他getter作为第二个参数</span></span><br><span class="line">    leftItems: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> getters.activeTodos.length,</span><br><span class="line">    <span class="comment">// 定义可作为方法调用的带参getter</span></span><br><span class="line">    getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> <span class="function"><span class="params">id</span> =&gt;</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>getters 在子组件中可作为计算属性访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  activeTodos: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.activeTodos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用<code>mapGetters()</code>方法访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">'activeTodos'</span>, <span class="string">'leftItems'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>在 store 中注册包含载荷的 mutation</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, amount) &#123;</span><br><span class="line">    state.count += amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注册的 mutation 都必须是同步函数，否则会导致状态的改变不可追踪。</strong></p>
<p>提交 mutations</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">"increment"</span>);</span><br></pre></td></tr></table></figure>

<p>提交带载荷的 mutations</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">"increment"</span>, &#123; <span class="attr">amount</span>: <span class="number">2</span> &#125;);</span><br><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">"increment"</span>,</span><br><span class="line">  amount: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件中提交 mutations</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"increment"</span>);</span><br></pre></td></tr></table></figure>

<p>或者使用<code>mapMutations()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations([<span class="string">'increment'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>在 store 中注册 action</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">action: &#123;</span><br><span class="line">  increment (context) &#123;</span><br><span class="line">    context.commit(<span class="string">'increment'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>action 函数接收的 <code>context</code> 参数与 store 实例具有相同的方法和 getters，因此可以通过<code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters，也可以调用 <code>context.commit</code> 提交一个 mutation。</p>
<p>action 和 mutation 的区别在于：</p>
<ul>
<li>action 需要通过提交 mutation 来实现状态的更新</li>
<li><strong>action 中可以包含异步操作</strong>，例如</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData());</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>); <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分发 action</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">"increment"</span>, &#123; <span class="attr">amount</span>: <span class="number">2</span> &#125;);</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">"increment"</span>,</span><br><span class="line">  amount: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件中则需要使用<code>this.$store.dispatch(...)</code>或者<code>mapActions()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([<span class="string">'increment'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>plugin 中会暴露出每次 mutation 的钩子，用于中 mutation 之后做额外的处理，例如数据持久化等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> localStoragePlugin = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当 store 初始化后调用</span></span><br><span class="line">  store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次 mutation 之后调用</span></span><br><span class="line">    <span class="comment">// mutation 的格式为 &#123; type, payload &#125;</span></span><br><span class="line">    localStorage.setItem(<span class="string">"todos"</span>, <span class="built_in">JSON</span>.stringify(state.todos));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vue 官方文档</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>理解Flux</title>
    <url>/2020/03/10/%E7%90%86%E8%A7%A3Flux/</url>
    <content><![CDATA[<p>Flux 是一种前端应用开发架构，是一种管理数据流的模式。当访问数据对象时，一个组件实例只是简单的代理访问。如果有一处需要被多个实例共享的状态，可以简单的通过维护一份数据来实现共享。</p>
<a id="more"></a>

<h2 id="Flux-中的关键概念"><a href="#Flux-中的关键概念" class="headerlink" title="Flux 中的关键概念"></a>Flux 中的关键概念</h2><ul>
<li><strong>Dispatcher</strong>：是 App 的调度中心，接收 action 并分发给 store。一个 App 里只有一个 dispatcher。</li>
<li><strong>Store</strong>：存储 App 的 data 和逻辑，且 store 中的 data 只能经由 action 修改，当 data 发生变化时会出发 change 事件通知 view 更新。store 注册在 dispatcher 上，并且给 dispatcher 提供一个回调函数用来更新自身，该回调函数接收 action 作为参数。一个 App 里可以有多个 store。</li>
<li><strong>Action</strong>：是一个简单的对象，可以理解为 App 内部的 API，由 type 和 data 组成，用于语义化的描述 App 内发生的变化。每个 action 都会被所有的 store 接收到。一个组件里会存在很多 action。</li>
<li><strong>View</strong>：请求 store 中的 data 用于展示，在用户与 App 进行交互时发出 action，并通过监听 store 的 change 事件重新渲染。</li>
</ul>
<p>以 Todo List 这样的简单 App 展示一下上述概念之间的关系：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1gcopqnhzojj219c0qyad6.jpg" alt="Flux原理"></p>
<p>上图表明的是 Flux 架构是如何工作的，需要注意的是，在 Flux 架构中，<strong>数据的流动是单向的</strong>，可以理解为</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1gcosksq60nj215a0dkta7.jpg" alt="数据的流动"></p>
<h2 id="Flux-架构的优势"><a href="#Flux-架构的优势" class="headerlink" title="Flux 架构的优势"></a>Flux 架构的优势</h2><p>Flux 架构带来的优势是，不存在数据双向绑定的情况，App 的状态完全由 store 控制，App 中各组件可以做到较好的解耦。</p>
<p>比如下图中的情况，如果底层组件 G 的某个行为想改变组件 F 的状态，数据需要先从 G 传递到根组件 A 再传递给 F。当 App 中有大量类似的复杂的数据传递路径后，用户与 App 的一次交互所引起的 App 的状态变更将会变得难以预测。即存在</p>
<blockquote>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
</blockquote>
<p>而在 Flux 架构中，store 作为一个类似于全局变量的存在持有着 App 所有的公共状态，并与每个组件间维持单一的数据流，我们很容易看到一个状态的变更引起了哪个组件的变化。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1gcoutggr5qj21ig0mo770.jpg" alt="Flux架构给组件间数据流动带来的改变"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/facebook/flux/tree/master/examples/flux-concepts" target="_blank" rel="noopener">Flux Concepts</a></li>
<li><a href="https://facebook.github.io/flux/docs/in-depth-overview" target="_blank" rel="noopener">Flux - In-Depth Overview</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Stroybook的基本使用</title>
    <url>/2020/03/09/Stroybook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Storybook 作为一个 UI 开发工具，能帮助开发人员独立创建组件，并在隔离的开发环境中以交互方式展示组件。 Storybook 是在主应用程序之外运行的，因此用户可以独立开发 UI 组件，而不必担心应用程序特定的依赖关系和要求。</p>
<p>Storybook 的基本思想是遵循 CDD + TDD 原则进行组件开发。</p>
<p>CDD 是 Component Drive Development，即以组件为基础自底而上的开发流程，每个组件都可作为一个独立的 story 进行开发。</p>
<p>TDD 是 Test Drive Development，在开发过程中对每个组件进行 UI 及功能上的测试。</p>
<p>本文介绍在 Vue 框架下的 App 中使用 Storybook 的方法。</p>
<a id="more"></a>

<hr>
<p>以下图所示的 Taskbox App 为例。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1gcnrhybvf7j218k0xewia.jpg" alt="Screen Shot 2020-03-09 at 16.34.56.png"></p>
<h2 id="Setup-Vue-Storybook"><a href="#Setup-Vue-Storybook" class="headerlink" title="Setup Vue Storybook"></a>Setup Vue Storybook</h2><p>使用 Vue CLI 创建 App，并启用 Storybook 和 Jest 测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create our application, using a preset that contains jest:</span></span><br><span class="line">npx -p @vue/cli vue create taskbox --preset hichroma/vue-preset-learnstorybook</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> taskbox</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add Storybook:</span></span><br><span class="line">npx -p @storybook/cli sb init</span><br></pre></td></tr></table></figure>

<p>可以使用以下命令检查 App 是否初始化成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run the test runner (Jest) in a terminal:</span></span><br><span class="line">npm run <span class="built_in">test</span>:unit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the component explorer on port 6006:</span></span><br><span class="line">npm run storybook</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the frontend app proper on port 8080:</span></span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="创建组件的-Story"><a href="#创建组件的-Story" class="headerlink" title="创建组件的 Story"></a>创建组件的 Story</h2><p>使用 TDD 的开发模式，在开发每个组件时为这个组件创建一个或多个 story，例如：</p>
<ul>
<li>组件：<code>Task.vue</code></li>
<li>组件的 story：<code>Task.stories.js</code></li>
</ul>
<p>上述 Taskbox 的最基础组件就是 Task，一个 Task 包含 title、state 两个属性，及 onPinTask、onArchiveTask 两个事件。Task 组件的 story 样例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/Task.stories.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用stroybook提供的addon-actions库来mock事件的处理</span></span><br><span class="line"><span class="keyword">import</span> &#123; action &#125; <span class="keyword">from</span> <span class="string">'@storybook/addon-actions'</span>;</span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> Task <span class="keyword">from</span> <span class="string">'./Task.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// story的标题</span></span><br><span class="line">  title: <span class="string">'Task'</span>,</span><br><span class="line">  <span class="comment">// 排除不需要storybook渲染的文件</span></span><br><span class="line">  excludeStories: <span class="regexp">/.*Data$/</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock事件处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actionsData = &#123;</span><br><span class="line">  onPinTask: action(<span class="string">'onPinTask'</span>),</span><br><span class="line">  onArchiveTask: action(<span class="string">'onArchiveTask'</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建测试数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> taskData = &#123;</span><br><span class="line">  id: <span class="string">'1'</span>,</span><br><span class="line">  title: <span class="string">'Test Task'</span>,</span><br><span class="line">  state: <span class="string">'Task_INBOX'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task组件为TASK_PINNED状态时的story</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Pinned = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  components: &#123; Task &#125;,</span><br><span class="line">  template: <span class="string">`&lt;task :task="task" @archiveTask="onArchiveTask" @pinTask="onPinTask"/&gt;`</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    task: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        ...taskData,</span><br><span class="line">        state: <span class="string">'TASK_PINNED'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: actionsData,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task组件为其他状态的story</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上述 story 样例里包含了几个<strong>关键点</strong>：</p>
<ul>
<li>通过指定不同 props，我们可以创建不同状态下的组件，以测试组件 UI 是否符合预期</li>
<li>我们只关心组件的行为是否能正确发生（如是否正确传参）而不关心后续的处理，因此我们可以将事件处理 mock 掉</li>
<li>将 mock 的 action、测试数据等 export 出去可以便于我们在其他 story 中复用</li>
<li>每一个 story 都是该组件的一个可视化测试，启动 storybook 后就可以看到对应的测试：</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1gcnspdedo9j22ic16oq83.jpg" alt="Screen Shot 2020-03-09 at 17.17.35.png"></p>
<p>运行 story 所需的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .storybook/main.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  stories: [<span class="string">"../src/components/**/*.stories.js"</span>],</span><br><span class="line">  addons: [<span class="string">"@storybook/addon-actions"</span>, <span class="string">"@storybook/addon-links"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果希望 storybook 加载 app 引用的样式文件，还需要配置 <code>preview.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .storybook/preview.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../src/index.css"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Vuex-对组件-Story-的影响"><a href="#Vuex-对组件-Story-的影响" class="headerlink" title="Vuex 对组件 Story 的影响"></a>Vuex 对组件 Story 的影响</h2><p>当 App 里状态较多且某些状态需要被多个实例共享时我们会考虑使用 Vuex 管理组件间的数据流，但使用 Vuex 之后组件对外部数据的依赖性增加了，不便于隔离测试， 因此较好的实践是将引入的 Vuex 状态管理抽离成一个容器组件，例如：</p>
<ul>
<li><p>原组件：<code>PureTask.vue</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class&#x3D;&quot;taskClass&quot;&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type&#x3D;&quot;checkbox&quot;</span><br><span class="line">      :checked&#x3D;&quot;isChecked&quot;</span><br><span class="line">      @click&#x3D;&quot;$emit(&#39;archiveTask&#39;, task.id)&quot;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; :readonly&#x3D;&quot;true&quot; :value&#x3D;&quot;this.task.title&quot; &#x2F;&gt;</span><br><span class="line">    &lt;a @click&#x3D;&quot;$emit(&#39;pinTask&#39;, task.id)&quot;&gt;&lt;span class&#x3D;&quot;icon-star&quot;&#x2F;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;pure-task&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    task: &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器组件：<code>Task.vue</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;pure-task :task&#x3D;&quot;task&quot; @archiveTask&#x3D;&quot;archiveTask&quot; @pinTask&#x3D;&quot;pinTask&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import PureTask from &quot;.&#x2F;PureTask.vue&quot;;</span><br><span class="line">import &#123; mapState, mapActions &#125; from &quot;vuex&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;task&quot;,</span><br><span class="line">  components: &#123; PureTask &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([&quot;archiveTask&quot;, &quot;pinTask&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&quot;task&quot;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这样 PureTask 组件就是一个可隔离的独立组件，我们可以对它写 story 测试而不用额外考虑数据上下文。</p>
<p>此外，当我们用 Task 组件构建外层的 TaskList 组件时，由于自组件 Task 依赖 Vuex 提供的状态 store，父组件 TaskList 不再是一个可隔离的独立组件，需要在它的 story 里提供 Vuex store 以为 Task 组件提供必需的数据上下文。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/components/TaskList.stories.js</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;...&#125;,</span><br><span class="line">  actions: &#123;...&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  title: <span class="string">'TaskList'</span>,</span><br><span class="line">  excludeStories: <span class="regexp">/.*store$/</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Default = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  components: &#123; TaskList &#125;,</span><br><span class="line">  template: <span class="string">`&lt;task-list/&gt;`</span>,</span><br><span class="line">  store,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Snapshot-Testing"><a href="#Snapshot-Testing" class="headerlink" title="Snapshot Testing"></a>Snapshot Testing</h2><p>快照测试是指记录给定输入的组件的“已知合格”输出，然后在将来输出发生变化时标记该组件的做法。 这样每次测试时可以看到我们对组件的哪部分进行了修改，当单元测试不通过时便于快速定位问题。</p>
<p><em>但在使用快照测试时应确保组件呈现不变的数据，以使快照测试不会每次都失败，例如是否存在日期或随机生成的值。</em></p>
<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D @storybook/addon-storyshots jest-vue-preprocessor</span><br></pre></td></tr></table></figure>

<p>创建 storybook 测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tests/unit/storybook.spec.js</span></span><br><span class="line"><span class="keyword">import</span> initStoryshots <span class="keyword">from</span> <span class="string">"@storybook/addon-storyshots"</span>;</span><br><span class="line"></span><br><span class="line">initStoryshots();</span><br></pre></td></tr></table></figure>

<p>在 Jest 配置文件 <code>jest.config.js</code> 中增加以下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">transformIgnorePatterns: [<span class="string">"/node_modules/(?!(@storybook/.*\\.vue$))"</span>]</span><br></pre></td></tr></table></figure>

<p>运行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接运行测试</span></span><br><span class="line">npm run <span class="built_in">test</span>:unit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试并更新 snapshot</span></span><br><span class="line">npm run <span class="built_in">test</span>:unit -- -u</span><br></pre></td></tr></table></figure>

<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>如果项目中引入了外部组件库，例如 Element-UI，为了处理外部组件库的样式文件，需要把样式文件 mock 掉。可以使用 <a href="https://github.com/keyanzhang/identity-obj-proxy" target="_blank" rel="noopener">ES6 Proxy</a> mock <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">CSS Modules</a>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D identity-obj-proxy</span><br></pre></td></tr></table></figure>

<p>并在 Jest 配置文件 <code>jest.config.js</code> 中增加以下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"moduleNameMapper"</span>: &#123;</span><br><span class="line">  <span class="string">"\\.(css|less)$"</span>: <span class="string">"identity-obj-proxy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Storybook 是一个 UI 开发工具库，它的核心思想是 CDD + TDD。使用 storybook 可以在隔离的开发环境中以交互方式展示独立的组件，方便对组件 UI 和行为进行测试；在团队开发中有助于保证组件 UI 的一致性，也可以避免大家重复造轮子。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.learnstorybook.com/intro-to-storybook/vue/en/get-started/" target="_blank" rel="noopener">Storybook for Vue tutorial</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Vue中计算属性和方法的区别</title>
    <url>/2020/03/08/Vue%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li>计算属性：计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</li>
<li>方法：每当触发重新渲染时，调用方法将总会再次执行函数。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Python的包管理工具</title>
    <url>/2020/02/08/Python%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h2><p>Pip 是 Python 的包管理工具，类似于 NPM</p>
<p>可以用 Pip 生成 Python 项目的依赖文件列表 <code>requirements.text</code>，类似于 <code>package.json</code></p>
<p>可以从官网（<a href="https://pypi.org/" target="_blank" rel="noopener">PyPI</a>）上查找依赖</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>以下情况无需单独安装 Pip：<ul>
<li>从<a href="https://www.python.org/" target="_blank" rel="noopener">官网</a>下载的 Python 2（版本 &gt;= 2.7.9）或 Python 3 （版本 &gt;= 3.4）</li>
<li>使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 安装的 Python</li>
<li>使用 Virtualenv 创建的虚拟环境</li>
</ul>
</li>
</ul>
<ol>
<li><p>下载 <code>get-pip.py</code>脚本</p>
<ul>
<li><p><a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">get-pip.py</a></p>
</li>
<li><p>在命令行中执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>运行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>安装 / 卸载 packages</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install [package_name]</span><br><span class="line">pip uninstall [package_name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <code>requirements.txt</code> 中的所有依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 <code>requirements.txt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已安装的 packages</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol>
<li>不方便构建一致的环境</li>
<li>需要额外的虚拟环境管理工具实现环境隔离</li>
<li>对多个不同的环境需要维护多个 <code>requirements.txt</code> 文件</li>
</ol>
<h2 id="Pipenv"><a href="#Pipenv" class="headerlink" title="Pipenv"></a>Pipenv</h2><p>Pipenv 集成了 Pip 和 Virtual Environment 的功能</p>
<p>Pipenv 会自动生成项目的配置文件 <code>Pipfile</code> 和 <code>Pipfile.lock</code>，类似于 <code>package.json</code> 和 <code>package-lock.json</code></p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>使用 Pip 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件 <code>.bash_profile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH="/Users/layla/Library/Python/3.7/bin:$PATH"</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>创建并进入虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure>

<p>默认会创建一个和当前目录同名的环境，如果配置了 <code>WORKON_HOME</code> 则该虚拟环境会存放于配置路径下</p>
</li>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装指定依赖</span></span><br><span class="line">pipenv install [package_name]</span><br><span class="line">pipenv install [package_name] --dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据 Pipfile 安装依赖</span></span><br><span class="line">pipenv install</span><br><span class="line">pipenv install --dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据 Pipfile.lock 安装依赖</span></span><br><span class="line">pipenv install --ignore-pipfile</span><br></pre></td></tr></table></figure>

<p>Pipenv 会自动查找项目根目录下是否存在 <code>requirements.txt</code> 文件，并安装其中的依赖。</p>
<p>也可以手动安装 <code>requirements.txt</code> 中的依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install -r requirements.txt</span><br><span class="line">pipenv install -r dev-requirements.txt --dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv uninstall [package_name]</span><br><span class="line">pipenv uninstall --all</span><br><span class="line">pipenv uninstall --all-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 Python 命令但不进入虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv run</span><br></pre></td></tr></table></figure>

<p>例如：<code>pipenv run python main.py</code></p>
</li>
<li><p>查询当前项目的虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv --venv</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://learnku.com/docs/python-guide/2018/install3-osx/3250" target="_blank" rel="noopener">Python 最佳实践指南 2018 - 2.2. 安装 Python 3 - Mac OS X</a></p>
</li>
<li><p><a href="https://learnku.com/docs/python-guide/2018/virtualenvs/3256" target="_blank" rel="noopener">Python 最佳实践指南 2018 - 3.1. Pipenv 和 Python 虚拟环境</a></p>
</li>
<li><p><a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip 20.0.2 documentation - Installation</a></p>
</li>
<li><p><a href="https://realpython.com/pipenv-guide/" target="_blank" rel="noopener">Pipenv: A Guide to the New Python Packaging Tool</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python虚拟环境</title>
    <url>/2020/02/07/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>虚拟环境是保持项目依赖独立的一种方式，避免项目间的依赖互相干扰</p>
<a id="more"></a>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li><p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m venv test_env</span><br></pre></td></tr></table></figure>

<p>该命令会在当前目录下创建一个名为 <code>test_env</code> 的文件夹，里面包含了 Python 解释器的副本、标准库、及其他必要的文件</p>
</li>
<li><p>激活虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> test_env/bin/activate</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟环境</p>
<p>删除对应文件夹及文件</p>
</li>
</ul>
<h2 id="Virtualenv"><a href="#Virtualenv" class="headerlink" title="Virtualenv"></a>Virtualenv</h2><p><a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">Virtualenv</a> 是一个用来创建虚拟环境的工具</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>创建虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv test_env</span><br></pre></td></tr></table></figure>

<p>创建时指定 Python 版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python2.7 test_env</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source test_env/bin/activate</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Virtualenvwrapper"><a href="#Virtualenvwrapper" class="headerlink" title="Virtualenvwrapper"></a>Virtualenvwrapper</h2><p><a href="https://virtualenvwrapper.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Virtualenvwrapper</a> 是 Virtualenv 的拓展库，是一个虚拟环境管理工具</p>
<p>它提供更简单的命令管理虚拟环境，并可以将所有的虚拟环境放在一起统一管理</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>使用 Pip 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenvwrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件 <code>.bash_profile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=~/Envs</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3.7</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkvirtualenv test_env</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 / 切换虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">workon test_env</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmvirtualenv test_env</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所有虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsvirtualenv</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="其他推荐配置"><a href="#其他推荐配置" class="headerlink" title="其他推荐配置"></a>其他推荐配置</h2><ul>
<li><p>强制全局使用虚拟环境</p>
<p>修改配置文件 <code>.bash_profile</code>：</p>
<ol>
<li><p>修改 Pip 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PIP_REQUIRE_VIRTUALENV=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>gpip</code> 命令进行全局安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpip() &#123;</span><br><span class="line">    PIP_REQUIRE_VIRTUALENV="" pip "$@"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://learnku.com/docs/python-guide/2018/virtualenvs/3256" target="_blank" rel="noopener">Python 最佳实践指南 2018 - 3.1. Pipenv 和 Python 虚拟环境</a></p>
</li>
<li><p><a href="https://learnku.com/docs/python-guide/2018/virtualenvs-lower-level-virtualenv/3257" target="_blank" rel="noopener">Python 最佳实践指南 2018 - 3.2. 底层虚拟环境 virtualenv</a></p>
</li>
<li><p><a href="https://learnku.com/docs/python-guide/2018/pip-virtualenv/3259" target="_blank" rel="noopener">Python 最佳实践指南 2018 - 4.2. Pip 和 Virtualenv 的更多配置</a></p>
</li>
<li><p><a href="https://docs.python.org/3/tutorial/venv.html" target="_blank" rel="noopener">The Python Tutorial - 12. Virtual Environments and Packages</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>.bash_profile、.profile、.bashrc 文件的区别</title>
    <url>/2020/02/06/bash-profile%E3%80%81profile%E3%80%81bashrc%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Mac 的.bash_profile、.profile、.bashrc 三个配置文件的区别</p>
<a id="more"></a>

<h2 id="配置文件的分类"><a href="#配置文件的分类" class="headerlink" title="配置文件的分类"></a>配置文件的分类</h2><ul>
<li><p>设置系统全局环境变量：</p>
<p><code>~/etc/profile</code>、<code>~/etc/bashrc</code></p>
</li>
<li><p>设置用户环境变量：</p>
<p><code>~/.bash_profile</code>、<code>~/.profile</code>、<code>~/.bashrc</code></p>
</li>
</ul>
<h2 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h2><p>当登入系统时候获得一个 shell 进程时，其读取环境配置的流程为:</p>
<ol>
<li><p>从 <code>~/etc/profile</code> 读入全局环境变量，并根据其内容读取额外的配置，如 <code>~/etc/profile.d</code> 和 <code>~/etc/inputrc</code></p>
</li>
<li><p>根据 shell 的类型读取用环境变量</p>
<ul>
<li><p>当 shell 为<strong>交互式登陆 shell</strong> 时，按照 <code>~/.bash_profile</code> –&gt; <code>~/.bash_login</code> –&gt; <code>~/.profile</code> –&gt; <code>~/.bashrc</code> 的顺序读取</p>
</li>
<li><p>当 shell 为<strong>交互式非登陆 shell</strong> 时，读取 <code>~/.bashrc</code></p>
</li>
<li><p>当 shell 为*<em>非交互式 shell *</em>时，读取环境变量 <code>BASH_ENV</code> 指定的配置文件</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><code>~/.bash_profile</code>、<code>~/.bash_login</code>、<code>~/.profile</code> 只在会话开始时被读取一次，而 <code>~/.bashrc</code> 则每次打开新的终端时都会被读取。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.jianshu.com/p/9d95e5e736da" target="_blank" rel="noopener">linux 关于 bashrc 与 profile 的区别</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/22990045/answer/23282396" target="_blank" rel="noopener">https://www.zhihu.com/question/22990045/answer/23282396</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Webpack和Parcel的区别</title>
    <url>/2019/12/17/Webpack%E5%92%8CParcel%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<p>Webpack 可配置性强，可进行定制化开发，适用于大型复杂项目，但配置较为复杂；</p>
<p>Parcel 可以做到开箱即用，但不方便按需构建，应用场景受限，更适用于简单 Web 项目。</p>
<ol>
<li>配置文件<ul>
<li>webpack 配置文件比较复杂，webpack 4+ 开始支持无配置构建</li>
<li>parcel 可以无配置构建</li>
</ul>
</li>
<li>依赖<ul>
<li>webpack 需要根据不同的构建需求安装不同的依赖，包括各种 loader 和 plugin</li>
<li>parcel 内置了常见场景的构建方案及其依赖，无需再安装各种依赖</li>
</ul>
</li>
<li>入口文件<ul>
<li>webpack 的入口文件为 JS 文件</li>
<li>paecel 的入口文件为 HTML 文件</li>
</ul>
</li>
<li>输出文件<ul>
<li>webpack<ul>
<li>根据配置的入口文件输出对应的 bundle 文件，一个入口文件对应一个 bundle，CSS 等文件会被编译进 bundle.js 中</li>
<li>输出文件较小</li>
</ul>
</li>
<li>parcel<ul>
<li>根据文件类型输出不同的编译好的文件</li>
<li>输出文件较大</li>
</ul>
</li>
</ul>
</li>
<li>构建速度<ul>
<li>webpack 的构建速度较慢</li>
<li>parcel 的构建速度较快，尤其是第二次构建</li>
</ul>
</li>
<li>热模块替换<ul>
<li>webpack 需配置</li>
<li>parcel 默认支持</li>
</ul>
</li>
<li>TreeShaking<ul>
<li>webpack 在生产模式下支持</li>
<li>parcel 不支持</li>
</ul>
</li>
<li>应用场景<ul>
<li>webpack 除用于构建网页外还可以打包 NPM 库、Node.js 应用等</li>
<li>parcel 只能用于构建网页</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000012612891" target="_blank" rel="noopener">Parcel Vs Webpack</a></li>
<li><a href="https://segmentfault.com/a/1190000014049700" target="_blank" rel="noopener">webpack VS parcel</a></li>
<li><a href="https://juejin.im/post/5bce882de51d457aa12dd12e" target="_blank" rel="noopener">构建工具对比</a></li>
</ul>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack的基本使用</title>
    <url>/2019/12/16/Webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><ul>
<li><p>Entry：可执行模块的入口（源代码入口）</p>
</li>
<li><p>Output：输出文件（分发代码）</p>
</li>
<li><p>Module：<code>import</code>、css 中的<code>@import</code>、<code>url(...)</code>、<code>&lt;img src=&quot;...&quot; /&gt;</code>…</p>
</li>
<li><p>Chunk：打包时生成的模块（一个可执行模块和其所有依赖模块的组合）</p>
</li>
<li><p>Bundle：打包完成的代码</p>
</li>
<li><p>Mode：development / production</p>
</li>
<li><p>Loader：用于加载模块时预处理文件，处理非原生 js 文件</p>
</li>
<li><p>Plugins：用于扩展 webpack 的功能，比如提供自动生成 html 页面、清理、模块热替换等功能</p>
</li>
<li><p>Configuration：<code>webpack.config.js</code></p>
</li>
<li><p>Dependency graph：从入口文件开始递归构建出，并由此进行打包</p>
</li>
<li><p>Runtime 和 Manifest：连接模块所需的加载和解析逻辑和模块标识集合</p>
</li>
<li><p>Hot Module Replacement：只更新模块， 而不用重载整个页面</p>
</li>
<li><p>Public Path：加载资源的公共路径</p>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>webpack</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br><span class="line">npm install --save-dev webpack@&lt;version&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack-cli（对于 webpack 4+ 版本）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-cli</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">  |- package.json</span><br><span class="line">  |- webpack.config.js</span><br><span class="line">  |- &#x2F;dist</span><br><span class="line">    |- index.html</span><br><span class="line">  |- &#x2F;src</span><br><span class="line">    |- index.js</span><br></pre></td></tr></table></figure>

<ul>
<li><code>webpack.config.js</code> 为 webpack 配置文件</li>
<li><code>/dist</code> 文件夹存放分发代码</li>
<li><code>/src</code> 文件夹存放源代码</li>
</ul>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>, <span class="comment">// 打包后的bundle文件</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>) <span class="comment">// 分发代码存放的目录，绝对路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Webpack 可以接受多个 <code>entry</code>，但只能指定一个 <code>output</code>。</p>
<h3 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h3><p>除 js 文件外，其他类型的文件需要使用额外的 loader 来加载。</p>
<h4 id="加载-CSS"><a href="#加载-CSS" class="headerlink" title="加载 CSS"></a>加载 CSS</h4><ul>
<li><p>NPM 安装 <a href="https://www.webpackjs.com/loaders/style-loader" target="_blank" rel="noopener">style-loader</a> 和 <a href="https://www.webpackjs.com/loaders/css-loader" target="_blank" rel="noopener">css-loader</a></p>
</li>
<li><p>修改配置文件</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8jky6hx83j212u0m4wgz.jpg" alt="Screen Shot 2019-11-02 at 12.25.38.png"></p>
</li>
</ul>
<blockquote>
<p><em>webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以</em> <code>.css</code> <em>结尾的全部文件，都将被提供给</em> <code>style-loader</code> <em>和</em> <code>css-loader</code><em>。</em></p>
</blockquote>
<p>使用上述方式打包时，CSS 文件将会被编译成含有 CSS 字符串的 <code>&lt;style&gt;</code> 标签，并插入到 html 文件的 <code>&lt;head&gt;</code> 中。当样式文件较大时可以利用 <a href="https://www.webpackjs.com/plugins/extract-text-webpack-plugin/" target="_blank" rel="noopener">extract-text-webpack-plugin</a> 插件将 CSS 打包成独立的文件。</p>
<h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><ul>
<li><p>NPM 安装 <a href="https://www.webpackjs.com/loaders/file-loader" target="_blank" rel="noopener">file-loader</a></p>
</li>
<li><p>修改配置文件</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8jl1485slj212s0sediz.jpg" alt="Screen Shot 2019-11-02 at 12.28.30.png"></p>
</li>
</ul>
<p>图像将被处理并添加到分发代码存放的目录中。</p>
<h3 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h3><h4 id="入口分离"><a href="#入口分离" class="headerlink" title="入口分离"></a>入口分离</h4><p>Webpack 接受多入口（例如多页面应用程序中），且可以配置根据入口起点名称动态生成 bundle 名称：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8joqfoog1j212u0fqdi5.jpg" alt="Screen Shot 2019-11-02 at 14.36.35.png"></p>
<p>打包后会在 <code>/dist</code> 目录下生成 <code>print.bundle.js</code> 和 <code>app.bundle.js</code> 两个文件。</p>
<h4 id="自动生成-index-html-并关联入口文件"><a href="#自动生成-index-html-并关联入口文件" class="headerlink" title="自动生成 index.html 并关联入口文件"></a>自动生成 <code>index.html</code> 并关联入口文件</h4><ul>
<li><p>NPM 安装 <a href="https://www.webpackjs.com/plugins/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a> 插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8jowrky2ij212u0k2ad7.jpg" alt="Screen Shot 2019-11-02 at 14.42.41.png"></p>
</li>
</ul>
<p><code>title</code> 属性用于指定生成的 <code>index.html</code> 中的<code>&lt;title&gt;</code>标签的内容。</p>
<p>配置该插件后则无需手动将各入口文件引入 <code>index.html</code> 中。</p>
<h4 id="清理-dist-文件夹"><a href="#清理-dist-文件夹" class="headerlink" title="清理 /dist 文件夹"></a>清理 <code>/dist</code> 文件夹</h4><p>即清理掉未在项目中使用的文件。</p>
<ul>
<li><p>NPM 安装 <a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a> 插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8jp5klgwtj212s0m4djq.jpg" alt="Screen Shot 2019-11-02 at 14.51.11.png"></p>
</li>
</ul>
<h4 id="提取公共入口-chunk"><a href="#提取公共入口-chunk" class="headerlink" title="提取公共入口 chunk"></a>提取公共入口 chunk</h4><p>当多个入口文件都引用了同样的模块时，可以利用 <a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">splitChunks</a> 插件在打包将该模块作为一个公共模块提取出来。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8op9zj77yj216q0t6wj0.jpg" alt="Screen Shot 2019-11-06 at 22.43.15.png"></p>
<ul>
<li><code>cacheGroups</code> 中的每一个键值对为一个公共模块的配置</li>
<li><code>name</code> 属性为生成的公共模块的名字</li>
<li><code>chunks</code> 属性用于指定打包的 chunks 的类型（<ul>
<li>包含三个选项：<code>initial</code>、<code>async</code>、<code>all</code></li>
<li>分别针对非动态加载的模块和动态加载的模块（使用 <code>import()</code> 引入的模块）采用不同的打包方式</li>
</ul>
</li>
</ul>
<h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><h4 id="追踪源代码"><a href="#追踪源代码" class="headerlink" title="追踪源代码"></a>追踪源代码</h4><p>使用 JavaScript 提供的 <a href="http://blog.teamtreehouse.com/introduction-source-maps" target="_blank" rel="noopener">source map</a> 功能，将编译后的代码映射回原始源代码。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8jpa4j75lj212u0n80wt.jpg" alt="Screen Shot 2019-11-02 at 14.55.34.png"></p>
<p><code>inline-source-map</code> 适用于开发环境，source map 还有很多<a href="https://www.webpackjs.com/configuration/devtool" target="_blank" rel="noopener">不同的选项</a>，需根据生产/开发环境进行选择。</p>
<h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ol>
<li><p>观察模式</p>
<p>使用该模式后修改依赖图中任意一个文件被更新时代码都会重新编译打包，而无需手动再次构建。</p>
<ul>
<li>添加脚本：<code>&quot;watch&quot;: &quot;webpack --watch&quot;</code></li>
</ul>
</li>
<li><p><a href="https://www.webpackjs.com/configuration/dev-server/" target="_blank" rel="noopener">webpack-dev-server</a></p>
<p>该依赖提供了一个 web 服务器来实现实时重新加载。</p>
<ul>
<li>NPM 安装 webpack-dev-server</li>
<li>修改配置文件（如下图）</li>
<li>添加脚本：<code>&quot;start&quot;: &quot;webpack-dev-server --open&quot;</code></li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8jpib4fi9j212u0qeq7h.jpg" alt="Screen Shot 2019-11-02 at 15.03.22.png"></p>
</li>
</ol>
<h3 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h3><p>HMR 只影响包含 HMR 代码的模块。</p>
<p>如果一个模块没有 HMR 处理函数，更新会冒泡，即，某个模块更新时，所依赖的模块均会重新加载。</p>
<h4 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h4><ul>
<li><p>修改配置文件</p>
<ul>
<li>引入 webpack 对象</li>
<li>需要开启热替换的模块不应作为入口 js</li>
<li>dev server 设置 hot 模式</li>
<li>引入 <code>HotModuleReplacementPlugin</code></li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8mbw3gvb1j210w0vmq8z.jpg" alt="Screen Shot 2019-11-04 at 21.28.44.png"></p>
</li>
<li><p>对模块应用 HMR 处理函数</p>
<p>如在使用 <code>print.js</code> 模块的 <code>index.js</code> 中：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8mc40zonmj211207u0uj.jpg" alt="Screen Shot 2019-11-04 at 21.36.35.png"></p>
</li>
</ul>
<h4 id="支持模块热替换的框架"><a href="#支持模块热替换的框架" class="headerlink" title="支持模块热替换的框架"></a>支持模块热替换的框架</h4><ul>
<li><p><a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">React Hot Loader</a></p>
</li>
<li><p><a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">React Hot Loader</a></p>
</li>
<li><p><a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">Vue Loader</a></p>
<p>…</p>
</li>
</ul>
<h3 id="配置多环境"><a href="#配置多环境" class="headerlink" title="配置多环境"></a>配置多环境</h3><ol>
<li><p>为不同环境创建独立的配置文件</p>
<ul>
<li><p><code>webpack.common.js</code>：通用配置</p>
</li>
<li><p><code>webpack.dev.js</code>：开发环境配置</p>
</li>
<li><p><code>webpack.prod.js</code>：生产环境配置</p>
</li>
</ul>
<p>可以使用 <a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="noopener"><code>webpack-merge</code></a> 在不同环境的配置文件中引入通用配置。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8okxzmlonj21cq0qitdr.jpg" alt="Screen Shot 2019-11-06 at 20.13.00.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g8ol58235hj21cs0daq5c.jpg" alt="Screen Shot 2019-11-06 at 20.20.17.png"></p>
</li>
</ol>
<p>2) 配置 NPM 脚本</p>
<ul>
<li><p>开发环境脚本</p>
<p><code>&quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;</code></p>
</li>
<li><p>生产环境脚本</p>
<p><code>&quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;</code></p>
</li>
</ul>
<p>###publicPath</p>
<h4 id="output-publicPath"><a href="#output-publicPath" class="headerlink" title="output.publicPath"></a><code>output.publicPath</code></h4><blockquote>
<p>The <code>publicPath</code> specifies the public URL address of the output files when referenced in a browser. This can be helpful when you want to host some or all output files on a different domain or on a CDN.</p>
</blockquote>
<p>例如， <code>index.html</code> 页面的访问路径为： <code>http://localhost:8080/${output.publicPath}</code></p>
<p>值为一个相对于服务器根路径的相对路径，默认值为 <code>/</code>。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g901pvin6oj21h40a4go1.jpg" alt="Screen Shot 2019-11-16 at 18.14.35.png"></p>
<h4 id="devServer-publicPath"><a href="#devServer-publicPath" class="headerlink" title="devServer.publicPath"></a><code>devServer.publicPath</code></h4><blockquote>
<p>The Webpack Dev Server also uses this to determine the path where the output files are expected to be served from.</p>
</blockquote>
<p>使用 devServer 时，打包后的文件会被存放在内存中，并由 <code>publicPath</code> 指定一个用于访问的相对路径，默认值为 <code>/</code> 。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g901pvin6oj21h40a4go1.jpg" alt="Screen Shot 2019-11-16 at 18.14.35.png"></p>
<p>（当配置了 <code>devServer.publicPath</code> 后，控制台输出的 <code>webpack output is served from ...</code> 指的就是 <code>devServer.publicPath</code> ，没有配置时指的是 <code>output.publicPath</code>）</p>
<p>当 <code>devServer.publicPath</code> 和 <code>output.publicPath</code> 配置的路径不同时，资源会无法加载。</p>
<h5 id="publicPath-与-contenBase"><a href="#publicPath-与-contenBase" class="headerlink" title="publicPath 与 contenBase"></a>publicPath 与 contenBase</h5><p>devServer 还有一个 <code>contenBase</code> 配置项，<code>contenBase</code> 指的是加载静态文件的路径，默认值是执行 webpack 打包命令的当前目录。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g903gp05k8j21dw09cq55.jpg" alt="Screen Shot 2019-11-16 at 19.14.56.png"></p>
<h4 id="部分-Loader-的-publicPath"><a href="#部分-Loader-的-publicPath" class="headerlink" title="部分 Loader 的 publicPath"></a>部分 Loader 的 publicPath</h4><p>file-loader、html-loader 等 loader 也可以配置 <code>publicPath</code>，用于指定使用该 loader 预编译的文件的访问路径。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g90x20j92oj212s08cwfd.jpg" alt="Screen Shot 2019-11-17 at 12.19.11.png"></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack打包原理</title>
    <url>/2019/12/16/Webpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Webpack 是一个打包模块的机制，它做的是分析代码、编译代码。</p>
<a id="more"></a>

<h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol>
<li>解析配置参数</li>
<li>注册所有配置的插件，好让插件监听 webpack 构建生命周期的事件节点，以做出对应的反应</li>
<li>从配置的入口文件开始解析文件构建 AST 语法树，递归找出每个文件所依赖的文件</li>
<li>在解析文件的过程中根据文件类型和 loader 配置对文件进行转换</li>
<li>递归并转换完后生成代码块，即 chunk</li>
<li>输出所有 chunk 到文件系统，形成 bundle 文件</li>
</ol>
<h2 id="输出文件分析"><a href="#输出文件分析" class="headerlink" title="输出文件分析"></a>输出文件分析</h2><p>以一个简单的项目为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">'./add.js'</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>Webpack 打包后的输出文件为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpackBootstrap 启动函数</span></span><br><span class="line"><span class="comment">// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 安装过的模块都存放在这里面</span></span><br><span class="line">  <span class="comment">// 作用是把已经加载过的模块缓存在内存中，提升性能</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 去数组中加载一个模块，moduleId 为要加载模块在数组中的 index</span></span><br><span class="line">  <span class="comment">// 作用和 Node.js 中 require 语句相似</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果需要加载的模块已经被加载过，就直接从内存缓存中返回</span></span><br><span class="line">    <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">      <span class="comment">// 模块在数组中的 index</span></span><br><span class="line">      i: moduleId,</span><br><span class="line">      <span class="comment">// 该模块是否已经加载完毕</span></span><br><span class="line">      l: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 该模块的导出值</span></span><br><span class="line">      exports: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 modules 中获取 index 为 moduleId 的模块对应的函数</span></span><br><span class="line">    <span class="comment">// 再调用这个函数，同时把函数需要的参数传入</span></span><br><span class="line">    modules[moduleId].call(</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      <span class="built_in">module</span>,</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这个模块标记为已加载</span></span><br><span class="line">    <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这个模块的导出值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Webpack 配置中的 publicPath，用于加载被分割出去的异步代码</span></span><br><span class="line">  __webpack_require__.p = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 __webpack_require__ 去加载 index 为 0 的模块，并且返回该模块导出的内容</span></span><br><span class="line">  <span class="comment">// index 为 0 的模块就是入口模块</span></span><br><span class="line">  <span class="comment">// __webpack_require__.s 的含义是启动模块对应的 index</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="number">0</span>));</span><br><span class="line">&#125;)(</span><br><span class="line">  <span class="comment">// 所有的模块都存放在了一个数组里，根据每个模块在数组的 index 来区分和定位模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">/* 0 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 执行第 1 个模块</span></span><br><span class="line">      __webpack_require__(<span class="number">1</span>)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述代码可以简写为一个立即执行函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行存放所有模块数组中的第0个模块</span></span><br><span class="line">  __webpack_require__(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;)([<span class="comment">/*存放所有模块的数组*/</span>])</span><br></pre></td></tr></table></figure>

<p>Webpack 将独立的模块文件合并到一个单独的 bundle 文件的原因在于浏览器必须通过网络请求加载文件。 如果模块数量较多，加载时间会很长，因此 webpack 把所有模块都存放在了数组中，通过执行一次网络请求来提高加载速率。</p>
<p>Webpack 在打包过程中还做了缓存优化： 加载过的模块会缓存在内存中，当某个模块第二次被访问时会直接去内存中读取被缓存的返回值。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/e24ed38d89fd" target="_blank" rel="noopener">webpack 打包原理</a></li>
<li><a href="https://imweb.io/topic/59324940b9b65af940bf58ae" target="_blank" rel="noopener">webpack 原理与实战</a></li>
<li><a href="https://imweb.io/topic/5a4cce35a192c3b460fce39b" target="_blank" rel="noopener">Webpack 原理-输出文件分析</a></li>
</ul>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷实践——站会</title>
    <url>/2019/07/14/%E6%95%8F%E6%8D%B7%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AB%99%E4%BC%9A/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="站会的目的"><a href="#站会的目的" class="headerlink" title="站会的目的"></a>站会的目的</h2><p>用于给团队成员建立一个固定的沟通渠道，保持流程的透明性， 使团队每个成员都能及时了解到项目的进展情况，并进行相应的调整。</p>
<h2 id="站会要做什么"><a href="#站会要做什么" class="headerlink" title="站会要做什么"></a>站会要做什么</h2><p>站会中每个人需要回答三个问题：</p>
<ol>
<li>我昨天完成了什么任务？</li>
<li>我今天计划完成什么任务？</li>
<li>我遇到了什么困难或阻碍？</li>
</ol>
<h2 id="站会的纪律"><a href="#站会的纪律" class="headerlink" title="站会的纪律"></a>站会的纪律</h2><ol>
<li>站会不能超过 15 分钟</li>
<li>每个人必须站着参加</li>
<li>站会必须在固定时间的地点开</li>
<li>站会中同一时间只能一个人发言</li>
<li>发言时仅回答三个问题，需要讨论的问题应在站会后安排专门时间讨论</li>
</ol>
<h2 id="站会的要点是什么"><a href="#站会的要点是什么" class="headerlink" title="站会的要点是什么"></a>站会的要点是什么</h2><ul>
<li>站会不是给 SrumMaster 的报告会，是团队成员相互交流的会</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Maven相关概念总结</title>
    <url>/2019/04/30/Maven%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="构建原理"><a href="#构建原理" class="headerlink" title="构建原理"></a>构建原理</h2><p>Maven 构建项目的规则是<code>约定大于配置</code>，约定指 Maven 提倡项目应遵循标准的目录结构、命名规范等，以便于 Maven 帮助用户自动化地完成项目的编译、测试、打包等一系列工作。</p>
<p>Maven 对项目的生命周期进行了规范，保证不同用户按照统一的规范实现项目的自动化构建。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Maven 项目的生命周期包含三部分：Clean、Build、Site</p>
<h3 id="Clean-生命周期"><a href="#Clean-生命周期" class="headerlink" title="Clean 生命周期"></a>Clean 生命周期</h3><p>Clean 生命周期用于在项目正式构建前进行一些清理工作，包含以下阶段：</p>
<ul>
<li>pre-clean：执行 clean 前需要完成的工作</li>
<li>clean：清理上次构建生成的文件</li>
<li>post-clean：执行 clean 后需要完成的工作</li>
</ul>
<h3 id="Build-生命周期"><a href="#Build-生命周期" class="headerlink" title="Build 生命周期"></a>Build 生命周期</h3><p>Build 生命周期用于构建项目，是 Maven 项目的主要生命周期，共包含 23 个阶段，主要的有：</p>
<ul>
<li>validate：验证项目正确且必要的信息可用</li>
<li>compile：编译代码</li>
<li>test：执行单元测试</li>
<li>package：打包编译后的代码</li>
<li>verify：运行集成测试以保证项目质量达标</li>
<li>install：将打包后的项目安装至本地仓库以供其他项目使用</li>
<li>deploy：在 build 环境上部署项目，并将打包后的项目发送到远程仓库</li>
</ul>
<h3 id="Site-生命周期"><a href="#Site-生命周期" class="headerlink" title="Site 生命周期"></a>Site 生命周期</h3><p>Site 生命周期用于生成项目的报告文档、站点，包含以下阶段：</p>
<ul>
<li>pre-site：执行生成站点文档前的工作</li>
<li>site：生成站点文档</li>
<li>post-site：执行生成站点文档后的工作，并未部署做准备</li>
<li>site-deploy：将生成的站点文档部署到服务器上</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Maven 项目的配置文件为项目根目录下的<code>pom.xml</code>文件，该文件中主要包含以下几部分：</p>
<ul>
<li><code>groupId</code>和<code>artifactId</code>标签分别表示组织/公司的标识和项目的标识，这两个 id 共同定义了这个项目在 Maven 仓库中的唯一坐标</li>
<li><code>version</code>标签表示项目的版本信息</li>
<li><code>build</code>标签用于定义项目的构建过程</li>
<li><code>dependency</code>标签用于定义项目依赖的外部库</li>
<li><code>repositories</code>标签用于定义项目的远程仓库</li>
</ul>
<p>例如：</p>
<ul>
<li>基本配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组织标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.extensions<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>beer-maven-lifecycle<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 项目的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-component-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 项目的远程仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构建配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构建出的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>myPorjectName<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构建产生的所有文件存放的目录,默认为项目根目录下的target --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目相关的所有资源路径列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 描述了资源的目标路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 包含的模式列表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>jdbc.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单元测试相关的所有资源路径，配制方法与resources类似 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目源码目录，相对于pom.xml路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目单元测试使用的源码目录相对于pom.xml路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\test\java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的一系列构建扩展 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.wagon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wagon-ssh<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用的插件列表  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 在构建生命周期中执行一组目标的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 执行目标的标识符 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 绑定了目标的构建生命周期阶段 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 配置的执行目标 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>Maven 仓库用于存储项目的依赖文件，分为本地仓库、远程仓库和中央仓库</p>
<ul>
<li><p>本地仓库</p>
<p>本地仓库位于开发人员自己的计算机上，保存着项目的所有依赖。在运行 Maven 构建时，Maven 会自动将所有依赖下载到本地仓库以供使用。</p>
<p>Maven 本地仓库默认被创建在<code>%USER_HOME%</code> 目录下。可以在 <code>%M2_HOME%\conf</code>目录中的<code>settings.xml</code>中修改</p>
</li>
<li><p>中央仓库</p>
<p>中央仓库由 Maven 社区提供，包含大量的常用库，通过网络进行访问，不需要进行配置。</p>
</li>
<li><p>远程仓库</p>
<p>远程仓库由项目组织定义，需要通过项目的 <code>pom xml</code>文件进行配置，</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/dcba1112/archive/2011/05/01/2033805.html" target="_blank" rel="noopener">Maven 的安装、配置及使用入门</a></li>
<li><a href="https://blog.csdn.net/qq_33363618/article/details/79438044" target="_blank" rel="noopener">Maven 之 pom.xml 配置文件详解</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Postman用法总结</title>
    <url>/2019/04/22/Postman%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Postman 快速上手<br>…</p>
<a id="more"></a>

<h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><p><img src="http://upload-images.jianshu.io/upload_images/14805043-4d29ae87bc8dca2b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="发送-GET-请求"><a href="#发送-GET-请求" class="headerlink" title="发送 GET 请求"></a>发送 GET 请求</h2><ol>
<li>选择 GET 方式</li>
<li>输入 URL</li>
<li>在 Params 里填项所需参数，填写的参数会出现在 URL 上</li>
<li>点击 Send 发送请求</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-cbe32d173812df45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>相应状态为 <code>200</code>表明请求被成功响应</p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-dd13dfcf421d61d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="发送-POST-请求"><a href="#发送-POST-请求" class="headerlink" title="发送 POST 请求"></a>发送 POST 请求</h2><h3 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h3><ol>
<li>选择 POST 方式</li>
<li>输入 URL</li>
<li>在 Body 中选择 <code>x-www-form-urlencoded</code>方式，并输入参数，Postman 会自动设置相应的 Header</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-ebaacf07764a9d33.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-258e8c710269c8a0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="JSON-提交"><a href="#JSON-提交" class="headerlink" title="JSON 提交"></a>JSON 提交</h3><ol>
<li>选择 POST 方式</li>
<li>输入 URL</li>
<li>在 Body 中选择 <code>raw</code>方式，设置格式为 <code>JSON(application/json)</code></li>
<li>输入参数，Postman 会自动设置相应的 Header</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-9f72d643d9ce1e16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-ef000e0cce5e77f8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="XML-提交"><a href="#XML-提交" class="headerlink" title="XML 提交"></a>XML 提交</h3><ol>
<li>选择 POST 方式</li>
<li>输入 URL</li>
<li>在 Body 中选择 <code>raw</code>方式，设置格式为 <code>XML(text/xml)</code></li>
<li>输入参数，Postman 会自动设置相应的 Header</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-bf195ac1f712a753.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-f6c5966b9d79855c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="二进制文件提交"><a href="#二进制文件提交" class="headerlink" title="二进制文件提交"></a>二进制文件提交</h3><ol>
<li>选择 POST 方式</li>
<li>输入 URL</li>
<li>在 Body 中选择 <code>binary</code>方式</li>
<li>上传二进制文件</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-74cb5e38e33ab5bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="测试请求"><a href="#测试请求" class="headerlink" title="测试请求"></a>测试请求</h2><p>使用 <code>Tests</code>可以通过断言来处理请求</p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-799b38a8285ae7ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们可以基于 Postman 提供的断言实现想要的处理</p>
<p>例如：</p>
<ul>
<li><code>Status code is 200</code>：断言响应状态为 200</li>
<li><code>Response body: Contains string</code>：断言响应内容为一个 String</li>
<li><code>Response body: JSON value check</code>：处理响应中的 JSON</li>
</ul>
<p>在 Test Results 中可以查看测试结果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-c79b3406794ba790.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>例如上图表明一个断言成功、两个失败</p>
<h2 id="请求集"><a href="#请求集" class="headerlink" title="请求集"></a>请求集</h2><p>使用 Collections 可以将多个请求管理起来</p>
<ol>
<li>创建集合</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-d5a09bb3688d9eab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-3eec8893453ea68f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol start="2">
<li>保存请求到一个集合</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-928ce39f2c6e27e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>[图片上传失败…(image-796389-1555939955258)]</p>
<ol start="4">
<li>可以创建文件夹整理集合内的请求</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-0e1b005dc99e3e0e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol start="5">
<li>运行一个集合内的请求</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/14805043-faeff5623ed64432.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/549ff9f922d6" target="_blank" rel="noopener">Postman 使用详解</a></li>
<li><a href="https://blog.csdn.net/fxbin123/article/details/80428216" target="_blank" rel="noopener">Postman 使用方法详解</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JSP和MVC的异同</title>
    <url>/2019/04/20/JSP%E5%92%8CMVC%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><p>JSP 和 MVC 是实现过程是相似的，基本来说都会经过以下几个步骤：</p>
<ul>
<li>接收用户的页面请求</li>
<li>调用相应数据</li>
<li>生成对应的页面</li>
<li>呈现给用户</li>
</ul>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p>JSP 和 MVC 最大的不同之处在于设计结构：</p>
<ul>
<li>JSP 中上述步骤统一由后端服务器完成，不对业务逻辑和展示逻辑加以区分，因而 JSP 也具有维护性差的缺点</li>
<li>MVC 中通过 Model、View、Controller 三个层次对上述步骤进行划分，每个层次具有不同的职责，业务逻辑和展示逻辑耦合性低，代码复用率更高，因而 MVC 相比 JSP 更易于维护</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/800px-MVC-Process.svg.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="noopener">Model–view–controller</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>理解事务的隔离特性</title>
    <url>/2019/04/03/%E7%90%86%E8%A7%A3%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h2><ul>
<li><strong>脏读</strong>：读到别的事务还未提交的修改</li>
<li><strong>不可重复读</strong>：读到别的事务已提交的修改，即在同一事务中多次查询结果不同</li>
<li><strong>幻读</strong>：由于未读到其他事务新插入或删除的数据导致后续插入或删除操作出错，即之前的查询结果是不真实的</li>
</ul>
<p>脏读和不可重复读都针对的是现有数据被修改的情况，幻读针对的是插入或删除新数据的情况。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>。不同级别的特性如下：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITED</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p>默认的隔离级别为<code>REPEATABLE READ</code>。</p>
<p>事务的隔离级别针对的是客户端，是对当前客户端的约束，限制当前客户端的读操作，即</p>
<ul>
<li>SERIALIZABLE 级别强制当前客户端发起的写事务等待其他客户端的写事务提交后再执行</li>
<li>REPEATABLE READ 级别限制当前客户端不能读到其他客户端的事务的修改</li>
<li>READ COMMITED 级别限制当前客户端不能读到其他客户端的事务未提交的修改</li>
<li>READ UNCOMMITED 级别不对当前客户端的读事务进行限制</li>
</ul>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>以如下的 score 表为例：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>student_id</th>
<th>subject_id</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1001</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1002</td>
<td>80</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1001</td>
<td>60</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>1002</td>
<td>60.5</td>
</tr>
</tbody></table>
<p>运行两个并行的事务：事务 A 和事务 B。</p>
<p>其中，事务 A 执行对 score 表中的 score 列的修改操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line">	score</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">	score = score + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br></pre></td></tr></table></figure>

<p>事务 B 执行对 score 表的查询操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br></pre></td></tr></table></figure>

<h3 id="隔离级别为-REPEATABLE-READ-时"><a href="#隔离级别为-REPEATABLE-READ-时" class="headerlink" title="隔离级别为 REPEATABLE READ 时"></a>隔离级别为 REPEATABLE READ 时</h3><p>在事务 A 还未提交修改时，事务 B 查询 score 表时，查询不到事务 A 执行的修改：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pjkf32bej206r02uwea.jpg" alt=""></p>
<p>即<strong>没有发生脏读现象</strong>。</p>
<p>当事务 A 提交（<code>COMMIT</code>）上述修改后，事务 B 查询 score 表的结果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pjkf32bej206r02uwea.jpg" alt=""></p>
<p>同样查询不到事务 A 执行的修改，即<strong>没有发生不可重复读现象</strong>。</p>
<p>因此在<code>REPEATABLE READ</code>隔离等级下，查询到的是表的历史版本。</p>
<p>如果在事务 A 提交之前想在事务 B 中修改表中的数据，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line">	score</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">	score = score - <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 在运行一段时间后会如下错误：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pjwpk3xpj20vg00ma9v.jpg" alt=""></p>
<p>这是因为事务 B 在等待事务 A 先提交所做的修改，并且因为等待超时报错。</p>
<p>这说明事务在执行过程中禁止当其他事务存在未提交修改时同时修改数据。</p>
<p>如果事务 A 在原表中插入一条数据，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="number">5</span>, <span class="number">3</span>, <span class="number">1001</span>, <span class="number">85</span>);</span><br></pre></td></tr></table></figure>

<p>无论事务 A 是否提交该数据，事务 B 的查询结果均为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pkvh86vkj206t02w0sj.jpg" alt=""></p>
<p>即事务 B 查询不到新插入的数据，但此时如果事务 B 想在表中插入同样的数据时，运行会报错：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pl8332laj20vn00pt8j.jpg" alt=""></p>
<p>即<strong>发生了幻读现象</strong>。</p>
<h3 id="隔离级别为-READ-COMMITED-时"><a href="#隔离级别为-READ-COMMITED-时" class="headerlink" title="隔离级别为 READ COMMITED 时"></a>隔离级别为 READ COMMITED 时</h3><p>在事务 A 还未提交修改时，事务 B 查询 score 表的结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pk49dgfuj206r02uwea.jpg" alt=""></p>
<p>此时，事务 B 查询不到事务 A 未提交的修改，即<strong>没有发生脏读现象</strong>。</p>
<p>当事务 A 提交上述修改后，事务 B 的查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pk8tj93kj206t02w0sj.jpg" alt=""></p>
<p>此时，事务 B 可以查询到事务 A 提交后的修改，即<strong>发生了不可重复读现象</strong>。</p>
<p>如果事务 A 在原表中插入一条数据，事务 B 查询不到新插入的数据，但此时如果事务 B 想在表中插入同样的数据时，运行会报错：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pl8332laj20vn00pt8j.jpg" alt=""></p>
<p>即<strong>发生了幻读现象</strong>。</p>
<h3 id="隔离级别为-READ-UNCOMMITED-时"><a href="#隔离级别为-READ-UNCOMMITED-时" class="headerlink" title="隔离级别为 READ UNCOMMITED 时"></a>隔离级别为 READ UNCOMMITED 时</h3><p>在事务 A 还未提交修改时，事务 B 查询 score 表的结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pkihcyc0j206t02w0sj.jpg" alt=""></p>
<p>此时，事务 B 可以查询到事务 A 未提交的修改，即<strong>发生了脏读现象</strong>。</p>
<p>当事务 A 提交上述修改后，事务 B 的查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pk8tj93kj206t02w0sj.jpg" alt=""></p>
<p>此时，事务 B 可以查询到事务 A 提交后的修改，即<strong>发生了不可重复读现象</strong>。</p>
<p>如果事务 A 在原表中插入一条数据，事务 B 查询不到新插入的数据，但此时如果事务 B 想在表中插入同样的数据时，运行会报错：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pl8332laj20vn00pt8j.jpg" alt=""></p>
<p>即<strong>发生了幻读现象</strong>。</p>
<h3 id="隔离级别为-SERIALIZABLE-时"><a href="#隔离级别为-SERIALIZABLE-时" class="headerlink" title="隔离级别为 SERIALIZABLE 时"></a>隔离级别为 SERIALIZABLE 时</h3><p>在事务 A 还未提交修改时，事务 B 查询 score 表的结果时，MySQL 在运行一段时间后会报如下错误：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pknjn5d9j20vg00ma9v.jpg" alt=""></p>
<p>这表明事务 B 一直在等待事务 A 提交其修改直到超时。</p>
<p>说明了当前的隔离级别实际上是将并行的事务强制串行执行了。</p>
<p>当事务 A 提交上述修改后，事务 B 查询 score 表的结果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pjkf32bej206r02uwea.jpg" alt=""></p>
<p>同样查询不到事务 A 执行的修改，即<strong>没有发生不可重复读现象</strong>。</p>
<p>如果事务 A 在原表中插入一条数据，在事务 A 还未交该数据时，事务 B 想插入同样的数据，MySQL 在运行一段时间后会报如下错误：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1pknjn5d9j20vg00ma9v.jpg" alt=""></p>
<p>这表明事务 B 一直在等待事务 A 提交其修改直到超时。</p>
<p>即<strong>没有发生幻读现象</strong>。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL规范总结</title>
    <url>/2019/04/01/SQL%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>遵循一定的规范有助于提高代码的可读性和可移植性，对 SQL 来说规范中最主要的是命名规范和代码规范，这里给出了一些通用的规范，具体应该遵循的规范需要依据项目要求来确定。</p>
<a id="more"></a>

<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="可用字符"><a href="#可用字符" class="headerlink" title="可用字符"></a>可用字符</h3><ul>
<li><p>对 SQL 来说，命名可用的字符包括 A-Z、a-z、0-9 及下划线。</p>
</li>
<li><p>命名时尽量不用数字。</p>
</li>
<li><p>下划线用于分割单词，不要以下划线作为开头或结尾</p>
</li>
</ul>
<h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><ul>
<li><p>使用英文而非拼音</p>
</li>
<li><p>做到见名知义</p>
</li>
<li><p>使用带有集合意义的词语，使用单数形式</p>
<p>例如：用 stuff 而不是 employees</p>
</li>
<li><p>表明和列明尽量不要重名</p>
</li>
<li><p>避免通过组合两个表明来命名关系表</p>
</li>
</ul>
<h3 id="大小写规范"><a href="#大小写规范" class="headerlink" title="大小写规范"></a>大小写规范</h3><ul>
<li>数据库名，小写，单词间用下划线分隔</li>
<li>表名，小写，单词间用下划线分隔</li>
<li>列名，小写，单词间用下划线分隔</li>
<li>别名，小驼峰命名法</li>
</ul>
<h3 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h3><ul>
<li>命名尽可能详细准确，但切忌太过冗长</li>
<li>表名、列名尽量限制在 30 字符以内</li>
</ul>
<h3 id="单词缩写"><a href="#单词缩写" class="headerlink" title="单词缩写"></a>单词缩写</h3><ul>
<li><p>谨慎使用缩写</p>
</li>
<li><p>表名超过 15 字符、列名超过 20 字符时可以考虑用缩写</p>
</li>
<li><p>获得单词对应的缩写的方法：</p>
<ul>
<li>查字典</li>
<li>推荐网站：<a href="http://shortof.com/" target="_blank" rel="noopener">http://shortof.com/</a></li>
<li>删除除首字母外的元音字符和重复字符</li>
</ul>
</li>
<li><p>对于主从表，从表从第二个单词开始缩写</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>外键的命名建议采用“主表名_字段名”的形式</p>
<p>例如：student_id</p>
</li>
<li><p>表示日期和时间字段建议通过后缀指明该字段精确到什么范围</p>
<p>例如：birth_date 说明精确到日期</p>
</li>
<li><p>含义为“是否…”的布尔型字段前缀加 is</p>
<p>例如：is_success、is_active</p>
</li>
</ul>
<h2 id="语句规范"><a href="#语句规范" class="headerlink" title="语句规范"></a>语句规范</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>关键字使用大写形式，以和其他代码区分</li>
<li>尽量使用关键字的全称而非缩写，以增强可读性</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student;</span><br></pre></td></tr></table></figure>

<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>通过适当的空格、换行和缩进来提高代码的可读性</p>
<ul>
<li><p>可以添加空格的地方：</p>
<ul>
<li>运算符两侧</li>
<li>逗号后</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span>, age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	age &gt; <span class="number">18</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以添加换行的地方：</p>
<ul>
<li><code>AND</code>和<code>OR</code>关键字另起一行</li>
<li>分号后另起一行</li>
<li>每个关键字的定义之后另起一行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span>, age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'王%'</span></span><br><span class="line">	<span class="keyword">AND</span> age &gt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以添加缩进的地方：</p>
<ul>
<li>联结查询应缩进</li>
<li>子查询应缩进</li>
<li>对字段的约束应缩进</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>, <span class="keyword">SUM</span>(score) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    score <span class="keyword">ON</span> student.id = student_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h3><p>保持代码的简洁性，去掉不必要的 SQL 语句</p>
<ul>
<li>能用<code>BETWEEN</code>指定查询条件的地方不要用<code>AND</code>加多个子句的形式</li>
<li>能用<code>IN</code>指定查询条件的地方不要用<code>OR</code>加多个子句的形式</li>
<li>尽量少使用<code>UNION</code>和临时表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 正例</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 反例</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	age &gt; <span class="number">18</span></span><br><span class="line">	<span class="keyword">AND</span> age &lt; <span class="number">22</span>;</span><br></pre></td></tr></table></figure>

<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul>
<li>使用标准的 SQL 函数来保证代码的可移植性</li>
<li>在必要的地方添加注释，不要滥用注释</li>
</ul>
<h2 id="创建表的规范"><a href="#创建表的规范" class="headerlink" title="创建表的规范"></a>创建表的规范</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>使用 SQL 标准数据类型以保证可移植性</p>
</li>
<li><p>仅在必要的时候使用<code>REAL</code>和<code>FLOAT</code>类型，尽量使用<code>NUMERIC</code>和<code>DECIMAL</code>类型</p>
<p>因为<code>FLOAT</code>型存在圆整错误</p>
</li>
</ul>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul>
<li><p>默认值应和字段类型相同</p>
<p>例如：对于<code>DOUBLE</code>类型的字段，其默认值应指定为 0.0 而非 0</p>
</li>
<li><p>默认值应定义在数据类型之后、<code>NOT NULL</code>约束之前</p>
<p>例如：<code>sex CHAR(1) DEFAULT &#39;男&#39; NOT NULL</code></p>
</li>
</ul>
<h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><ul>
<li>指定为键的字段的值应具有唯一性</li>
<li>键字段在各表中的类型应该保持一致，且发生改变的可能性较低</li>
<li>尽量使键为简单值，必要情况下也可以使用复合值</li>
</ul>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul>
<li><p>表应该至少拥有一个键</p>
</li>
<li><p>除<code>UNIQUE</code>、<code>PRIMARY KEY</code>、<code>FOREIGN KEY</code>外应给约束定义名称</p>
</li>
<li><p>约束的定义顺序：</p>
<ul>
<li><p>主键约束应定义在<code>CREATE TABLE</code>语句之后</p>
</li>
<li><p>各列约束应定义在列的下方，使用缩进对齐</p>
</li>
<li><p>涉及多个列的约束应尽量放置在涉及到的列的附近，如果不行的话放在表的创建的最后</p>
</li>
<li><p>对整个表的约束应该放在表的创建的最后</p>
</li>
<li><p>按照字母表的顺序排列约束</p>
<p>例如，<code>ON DELETE</code>约束应该在<code>ON UPDATE</code>约束之前</p>
</li>
</ul>
</li>
<li><p>定义必要的检查约束：</p>
<ul>
<li>当字符串类型的字段值格式已知时，使用<code>LIKE</code>和<code>SIMILAR TO</code>约束来检查</li>
<li>当数字类型的字段值范围已知时，利用<code>CHECK</code>约束语句来检查</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birth_date <span class="built_in">DATE</span>,</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">    	<span class="keyword">CONSTRAINT</span> sex_value</span><br><span class="line">    	<span class="keyword">CHECK</span> (sex <span class="keyword">IN</span> (<span class="string">'男'</span>, <span class="string">'女'</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/7e60dbd59138" target="_blank" rel="noopener">数据库设计中的命名规范</a></li>
<li><a href="https://www.sqlstyle.guide/" target="_blank" rel="noopener">SQL Style Guide</a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的索引用法总结</title>
    <url>/2019/03/28/MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>索引作为一种数据结构，其用途是用于提升检索数据的效率。</p>
<a id="more"></a>

<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL 中的索引共分为：</p>
<ul>
<li>普通索引（INDEX）：索引列值可重复</li>
<li>唯一索引（UNIQUE）：索引列值必须唯一，可以为 NULL</li>
<li>主键索引（PRIMARY KEY）：索引列值必须唯一，不能为 NULL，一个表只能有一个主键索引</li>
<li>全文索引（FULL TEXT）：给每个字段创建索引</li>
</ul>
<h2 id="不同类型索引用途的区别"><a href="#不同类型索引用途的区别" class="headerlink" title="不同类型索引用途的区别"></a>不同类型索引用途的区别</h2><ul>
<li>普通索引常用于过滤数据。例如，以商品种类作为索引，检索种类为“手机”的商品。</li>
<li>唯一索引主要用于标识一列数据不允许重复的特性，相比主键索引不常用于检索的场景。</li>
<li>主键索引是行的唯一标识，因而其主要用途是检索特定数据。</li>
<li>全文索引效率低，常用于文本中内容的检索。</li>
</ul>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ul>
<li><p>普通索引（INDEX）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在创建表时指定</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span>,</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">INDEX</span> nameIndex (<span class="keyword">name</span>(<span class="number">50</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于表结构创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> nameIndex <span class="keyword">ON</span> student(<span class="keyword">name</span>(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构创建</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> <span class="keyword">INDEX</span> nameIndex(<span class="keyword">name</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>唯一索引（UNIQUE）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在创建表时指定</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span>,</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> idIndex (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于表结构创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idIndex <span class="keyword">ON</span> student(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构创建</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idIndex(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键索引（PRIMARY KEY）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时时指定</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span>,</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构创建</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<p>主键索引不能使用基于表结构创建的方式创建。</p>
</li>
</ul>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><ul>
<li><p>普通索引（INDEX）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> nameIndex <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> <span class="keyword">INDEX</span> nameIndex;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唯一索引（UNIQUE）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idIndex <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> <span class="keyword">INDEX</span> idIndex;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键索引（PRIMARY KEY）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>

<p>主键不能采用直接删除的方式删除。</p>
</li>
</ul>
<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<h2 id="选择索引的原则"><a href="#选择索引的原则" class="headerlink" title="选择索引的原则"></a>选择索引的原则</h2><ul>
<li>常用于查询条件的字段较适合作为索引，例如<code>WHERE</code>语句和<code>JOIN</code>语句中出现的列</li>
<li>唯一性太差的字段不适合作为索引，例如性别</li>
<li>更新过于频繁（更新频率远高于检索频率）的字段不适合作为索引</li>
</ul>
<h2 id="使用索引的利弊"><a href="#使用索引的利弊" class="headerlink" title="使用索引的利弊"></a>使用索引的利弊</h2><ul>
<li>使用索引的好处是索引通过一定的算法建立了索引值与列值直接的联系，可以通过索引直接获取对应的行数据，而无需进行全表搜索，因而加快了检索速度</li>
<li>但由于索引也是一种数据结构，它需要占据额外的内存空间，并且读取索引也加会大 IO 资源的消耗，因而索引并非越多越好，且对过小的表也没有添加索引的必要</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>子查询、联结查询、组合查询用法总结</title>
    <url>/2019/03/27/%E5%AD%90%E6%9F%A5%E8%AF%A2%E3%80%81%E8%81%94%E7%BB%93%E6%9F%A5%E8%AF%A2%E3%80%81%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询就是在一个查询语句内部嵌套的查询，因而子查询语句也被称为内部查询、包含子查询语句的查询称为外部查询。这种查询语句的查询顺序是从内向外的。</p>
<p>常见的使用子查询的形式为：在<code>WHERE</code>语句内、在<code>IN</code>或<code>NOT IN</code>操作符后、在<code>FROM</code>语句内、在<code>EXISTS</code>或<code>NOT EXISTS</code>操作符后。</p>
<h3 id="在-WHERE-语句中使用子查询"><a href="#在-WHERE-语句中使用子查询" class="headerlink" title="在 WHERE 语句中使用子查询"></a>在 WHERE 语句中使用子查询</h3><p>可以在<code>WHERE</code>语句中使用子查询的结果对外部查询的数据进行过滤。</p>
<p>以下面的付款信息 payments 表为例：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ghjsa8nzj209s05mjre.jpg" alt=""></p>
<p>查询订单金额最大的客户的操作为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	customerNumber,</span><br><span class="line">    amount</span><br><span class="line"><span class="keyword">FROM</span> payments</span><br><span class="line"><span class="keyword">WHERE</span> amount = (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(amount)</span><br><span class="line">    <span class="keyword">FROM</span> payments</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ghlr4uf0j205f015a9t.jpg" alt=""></p>
<h3 id="在-IN-或-NOT-IN-操作符后使用子查询"><a href="#在-IN-或-NOT-IN-操作符后使用子查询" class="headerlink" title="在 IN 或 NOT IN 操作符后使用子查询"></a>在 IN 或 NOT IN 操作符后使用子查询</h3><p><code>IN</code>和<code>NOT IN</code>语句用于过滤出存在/不存在于子查询结果的数据。</p>
<p>例如在如下的顾客表 customers 和订单表 orders 中进行查询：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ghvczm23j20nb05idg3.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ghw91u76j20kj05z3yo.jpg" alt=""></p>
<p>查询出未产生订单的客户名单的操作为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customerName</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> customerNumber <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> customerNumber</span><br><span class="line">    <span class="keyword">FROM</span> orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1gi0oz6ibj205103r744.jpg" alt=""></p>
<h3 id="在-FROM-语句内使用子查询"><a href="#在-FROM-语句内使用子查询" class="headerlink" title="在 FROM 语句内使用子查询"></a>在 FROM 语句内使用子查询</h3><p>可以将子查询结果作为一个临时表用于<code>FROM</code>语句中。</p>
<p>以如下订单详情表 orderdetails 为例：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1gi4pyal8j20cd061dfv.jpg" alt=""></p>
<p>查询该表中的订单包含的商品种类的最大值、最小值和平均值的操作为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">MAX</span>(<span class="keyword">count</span>),</span><br><span class="line">    <span class="keyword">MIN</span>(<span class="keyword">count</span>),</span><br><span class="line">    <span class="keyword">FLOOR</span>(<span class="keyword">AVG</span>(<span class="keyword">count</span>))</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		orderNumber,</span><br><span class="line">        <span class="keyword">COUNT</span>(orderNumber) <span class="keyword">AS</span> <span class="keyword">count</span></span><br><span class="line">	<span class="keyword">FROM</span> orderdetails</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber</span><br><span class="line">) <span class="keyword">AS</span> orderCount;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1giby8884j2080015gld.jpg" alt=""></p>
<h3 id="在-EXISTS-或-NOT-EXISTS-操作符后使用子查询"><a href="#在-EXISTS-或-NOT-EXISTS-操作符后使用子查询" class="headerlink" title="在 EXISTS 或 NOT EXISTS 操作符后使用子查询"></a>在 EXISTS 或 NOT EXISTS 操作符后使用子查询</h3><p>使用<code>EXISTS</code>和<code>NOT EXISTS</code>操作符可以过滤出满足/不满足于子查询结果的数据。</p>
<p>以上述 customers 表、orders 表和 orderdetails 表为例，查询三个表中订单总额大于 60000 的顾客名单的操作为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	customerNumber,</span><br><span class="line">    customerName</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		orderNumber,</span><br><span class="line">        <span class="keyword">SUM</span>(quantityOrdered * priceEach) <span class="keyword">AS</span> total</span><br><span class="line">	<span class="keyword">FROM</span> orders</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orderdetails <span class="keyword">USING</span> (orderNumber)</span><br><span class="line">    <span class="keyword">WHERE</span> customerNumber = customers.customerNumber</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber</span><br><span class="line">    <span class="keyword">HAVING</span> total &gt; <span class="number">60000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1gkpci2hfj207902mdfn.jpg" alt=""></p>
<h2 id="联结查询"><a href="#联结查询" class="headerlink" title="联结查询"></a>联结查询</h2><p>联结查询是将多个表的数据放在一起进行查询。</p>
<p>联结查询包含内联结、外联结、交叉联结、自联结等，其中最常用的为内联结和外联结。</p>
<h3 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h3><p>内联结即查询两个表中数据的交集（如图），查询过程是将主表和副表的每一条数据都按照联结条件来匹配，只有满足联结条件的数据才会被保留。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hcrf357mj20ac05njrh.jpg" alt=""></p>
<p>内联结的语法：</p>
<ul>
<li><code>FROM</code>后跟随主表</li>
<li><code>INNER JOIN</code>后跟随副表</li>
<li><code>ON</code>后跟随联结条件</li>
</ul>
<p>内联结可以联结多个表来查询。</p>
<p>以如下的 student 表和 score 表为例：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hfp4mptfj205b0230si.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hf918lrwj206r02kjr6.jpg" alt=""></p>
<p>从两个表中检索出登记过成绩的各学生的总成绩的语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span>,</span><br><span class="line">    <span class="keyword">SUM</span>(score) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    score <span class="keyword">ON</span> student.id = student_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hfajb2z8j203701m741.jpg" alt=""></p>
<p>可以看到内联结仅取出了均存在于两个表的学生的成绩。</p>
<h3 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h3><p>外联结在查询过程中会保留主表中的所有数据，并对每一行数据按照指定的联结规则与附表匹配，若能匹配则取出副表中对应的数据，若不能匹配则该项以 NULL 填充。左外联结和右外联结的效果如下面两张图所示。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hfkrslz2j20eu04r0t3.jpg" alt=""></p>
<p>外联结的语法：</p>
<ul>
<li><code>FROM</code>后跟随主表</li>
<li><code>LEFT JOIN</code>或<code>RIGEHT JOIN</code>后跟随副表</li>
<li><code>ON</code>后跟随联结条件</li>
</ul>
<p>依旧以上述 student 表和 score 表为例。</p>
<p>从两个表中检索出所有各学生的总成绩的语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>,</span><br><span class="line">    <span class="keyword">SUM</span>(score) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    score <span class="keyword">ON</span> student.id = student_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>

<p>检索结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hfuuglcyj2038024dfl.jpg" alt=""></p>
<p>可以看到由于 score 表中没有王五的成绩，因此王五的总成绩为 NULL。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>组合查询是将多次查询的结果显示到一张表中，使用<code>UNION</code>关键字实现。</p>
<p><strong>其规则是</strong>：只有当多次查询的结果具有相似的结构（即相同数量的列，且对应列的类型相同或可以相互转换）时才能进行组合查询。</p>
<p>以上面的 student 表和 score 表为例。</p>
<p>查询出张三的平均分和总分的语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>, <span class="keyword">AVG</span>(score) <span class="keyword">AS</span> scoreInfor</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    score <span class="keyword">ON</span> student.id = student_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'张三'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span>, <span class="keyword">SUM</span>(score) <span class="keyword">AS</span> scoreInfor</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	student</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">	score <span class="keyword">ON</span> student.id = student_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">name</span> = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1hg9ntqxnj203v01na9t.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这三种方法的相同之处都是可以从多个相互关联的表中查询数据，相比单一表的查询更加使用。</p>
<p>不同之处在于：</p>
<ul>
<li>子查询是按照从内向外的顺序依次执行查询，主要用于使用子查询的结果作为基础进一步进行外层的查询，更适用于二次检索或过滤数据等操作。在嵌套曾经较少的情况下代码可读性较高，但检索效率较低。</li>
<li>联结查询是对不同表的数据进行了组合，并按照一定条件过滤；更适用于查询多表之间的共有数据（如内联结）或表数据的扩充（如外联结）等场景。</li>
<li>组合查询是将多次相似查询的结合进行合并展示的一种方式，主要用于对查询结果的聚合。</li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.mysqltutorial.org/mysql-subquery/" target="_blank" rel="noopener">MySQL Subquery</a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的GROUP BY用法小结</title>
    <url>/2019/03/26/MySQL%E7%9A%84GROUP-BY%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="利用聚合函数进行分组"><a href="#利用聚合函数进行分组" class="headerlink" title="利用聚合函数进行分组"></a>利用聚合函数进行分组</h2><p>使用<code>COUNT()</code>、<code>AVG()</code>、<code>MIN()</code>、<code>MAX()</code>等聚合函数可实现对分组的过滤，聚合函数会分别对各组数据进行聚合。</p>
<p>以下面的 orders 表为例：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g265uu9dj20km048jrf.jpg" alt=""></p>
<p>按照 status 列将订单分组并计算各组包含的订单条目数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">status</span>, <span class="keyword">COUNT</span>(<span class="keyword">status</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g2bgtjaej205703j3yb.jpg" alt=""></p>
<p>再以一个 orderdetails 表为例：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g4qbkhi9j20cd04qdfs.jpg" alt=""></p>
<p>若希望计算每个订单中包含商品的总价，则有</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	orderNumber,</span><br><span class="line">	<span class="keyword">SUM</span>(quantityOrdered * priceEach) <span class="keyword">AS</span> amount</span><br><span class="line"><span class="keyword">FROM</span> orderdetails</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g4sn4cksj204p054744.jpg" alt=""></p>
<h2 id="利用表达式进行分组"><a href="#利用表达式进行分组" class="headerlink" title="利用表达式进行分组"></a>利用表达式进行分组</h2><p><code>GROUP BY</code>语句中还可以使用函数或表达式来处理数据。</p>
<p>例如，从上述 orders 表和 orderdetails 表中查询每年订单总额：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">YEAR</span>(orderDate) <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">    <span class="keyword">SUM</span>(quantityOrdered * priceEach) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orderdetails <span class="keyword">USING</span> (orderNumber)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">YEAR</span>(orderDate);</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g5ixabpyj203z0240si.jpg" alt=""></p>
<h2 id="使用-HAVING-语句对分组结果进行过滤"><a href="#使用-HAVING-语句对分组结果进行过滤" class="headerlink" title="使用 HAVING 语句对分组结果进行过滤"></a>使用 HAVING 语句对分组结果进行过滤</h2><p><code>HAVING</code>语句可以过滤出分组后满足特定条件的数据。</p>
<p>例如，查找出总额大于 60000 的订单</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	orderNumber,</span><br><span class="line">    <span class="keyword">SUM</span>(quantityOrdered * priceEach) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orderdetails</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber</span><br><span class="line"><span class="keyword">HAVING</span> total &gt; <span class="number">60000</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g648qs0oj204t0243ya.jpg" alt=""></p>
<p><strong>注意</strong>：<br><code>WHERE</code>语句和<code>HAVING</code>语句虽然都可以对数据进行过滤，但用法是不同的，<code>HAVING</code>语句可以用于过滤分组，<code>WHERE</code>语句只能过滤行，不能过滤分组；因此<code>WHERE</code>语句应在<code>GROUP BY</code>之前使用。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	orderNumber,</span><br><span class="line">    <span class="keyword">SUM</span>(quantityOrdered * priceEach) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orderdetails</span><br><span class="line"><span class="keyword">WHERE</span> quantityOrdered &gt; <span class="number">50</span> <span class="keyword">AND</span> priceEach &gt; <span class="number">100</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber;</span><br></pre></td></tr></table></figure>

<p>查询结果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1g6i98ifjj204q04qa9w.jpg" alt=""></p>
<p>且<code>WHERE</code>语句中不能使用别名或者表达式，例如下列写法是不合法的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	orderNumber <span class="keyword">AS</span> orderId</span><br><span class="line"><span class="keyword">FROM</span> orderdetails</span><br><span class="line"><span class="keyword">WHERE</span> orderId &gt; <span class="number">100100</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt; Error Code: 1054. Unknown column 'orderId' in 'where clause'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	orderNumber,</span><br><span class="line">    <span class="keyword">SUM</span>(quantityOrdered * priceEach) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orderdetails</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SUM</span>(quantityOrdered * priceEach) &gt; <span class="number">60000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt; Error Code: 1111. Invalid use of group function	0.000 sec</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.mysqltutorial.org/mysql-group-by.aspx" target="_blank" rel="noopener">MySQL GROUP BY</a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中常用的文本处理函数和日期时间处理函数</title>
    <url>/2019/03/25/MySQL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="常用文本处理函数"><a href="#常用文本处理函数" class="headerlink" title="常用文本处理函数"></a>常用文本处理函数</h2><ul>
<li><p><code>CONCAT(str1, str2, ...)</code>：拼接字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CONCAT('There', ' is', ' an', ' apple.');</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| CONCAT('There', ' is', ' an', ' apple.') |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| There is an apple.                       |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CONCAT_WS(separator, str1, str2, ...)</code>：使用指定分隔符连接字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CONCAT_WS('-', 'There', 'is', 'an', 'apple');</span><br><span class="line">+<span class="comment">----------------------------------------------+</span></span><br><span class="line">| CONCAT_WS('-', 'There', 'is', 'an', 'apple') |</span><br><span class="line">+<span class="comment">----------------------------------------------+</span></span><br><span class="line">| There-is-an-apple                            |</span><br><span class="line">+<span class="comment">----------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LEFT(str, length)</code>：从左截取指定长度的子字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LEFT('ZHANG SAN', 5);</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| LEFT('ZHANG SAN', 5) |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| ZHANG                |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RIGHT(str, length)</code>：从右截取指定长度的子字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT RIGHT('ZHANG SAN', 3);</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| RIGHT('ZHANG SAN', 3) |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| SAN                   |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SUBSTRING(str, index, length)</code>：从指定位置处开始截取指定长度的子字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUBSTRING(&#39;ABCDEFG&#39;, 3, 4);</span><br><span class="line">+----------------------------+</span><br><span class="line">| SUBSTRING(&#39;ABCDEFG&#39;, 3, 4) |</span><br><span class="line">+----------------------------+</span><br><span class="line">| CDEF                       |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LENGTH(str)</code>：返回字符串的长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LENGTH('ZHANG SAN');</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| LENGTH('ZHANG SAN') |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">|                   9 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LOWER(str)</code>：将字符串转换为小写格式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LOWER('ZHANG SAN');</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| LOWER('ZHANG SAN') |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| zhang san          |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UPPER(str)</code>：将字符串转换为大写格式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT UPPER('zhang san');</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| UPPER('zhang san') |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| ZHANG SAN          |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LTRIM(str)</code>：去除字符串左侧的空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CONCAT('(', LTRIM('   LEFT'), ')');</span><br><span class="line">+<span class="comment">------------------------------------+</span></span><br><span class="line">| CONCAT('(', LTRIM('   LEFT'), ')') |</span><br><span class="line">+<span class="comment">------------------------------------+</span></span><br><span class="line">| (LEFT)                             |</span><br><span class="line">+<span class="comment">------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RTRIM(str)</code>：去除字符串右侧的空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CONCAT('(', RTRIM('RIGHT   '), ')');</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">| CONCAT('(', RTRIM('RIGHT   '), ')') |</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">| (RIGHT)                             |</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TRIM(str)</code>：去除字符串两侧的空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CONCAT('(', TRIM('   MIDDLE   '), ')');</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| CONCAT('(', TRIM('   MIDDLE   '), ')') |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| (MIDDLE)                               |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ELT(index, str1, str2, ...)</code>：返回字符串序列中指定位置的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ELT(3, 'A', 'B', 'C', 'D');</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| ELT(3, 'A', 'B', 'C', 'D') |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| C                          |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FIELD(str, str1, str2, ...)</code>：返回指定字符串 str 在字符串序列中的位置，找不到返回 0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FIELD('C', 'A', 'B', 'C', 'D');</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| FIELD('C', 'A', 'B', 'C', 'D') |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">|                              3 |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FIND_IN_SET(str, stringList)</code>：返回指定字符串 str 在由“<code>,</code>”分割的字符串序列中的位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FIND_IN_SET('C', 'A,B,C,D');</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| FIND_IN_SET('C', 'A,B,C,D') |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">|                           3 |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FORMAT(X, D)</code>：按照指定的小数位数 D 将数值 X 转化为字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FORMAT(123.45678, 2);</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| FORMAT(123.45678, 2) |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| 123.46               |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INSERT(str, index, length, newString)</code>：从指定位置开始用新字符串替换原字符串中指定长度的字符，index 超出原字符串范围时返回原字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT INSERT('ABCDEF', 3, 3, '123');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| <span class="keyword">INSERT</span>(<span class="string">'ABCDEF'</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'123'</span>) |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| AB123F                        |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LOCATE(substr, str)</code>：返回子字符串在指定字符串中第一次出现的位置</p>
<p><code>LOCATE(substr, str, index)</code>：从指定字符串的指定位置处开始查找子字符串出现的位置</p>
<p>找不到返回 0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LOCATE('a', 'banana');</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| LOCATE('a', 'banana') |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">|                     2 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT LOCATE('a', 'banana', 3);</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| LOCATE('a', 'banana', 3) |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">|                        4 |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LPAD(str, length, padStr)</code>：在字符串左侧用 padStr 将原字符串填充至指定长度，当指定长度小于原字符串长度时，截断原字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LPAD('HELLO', 8, '!');</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| LPAD('HELLO', 8, '!') |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| !!!HELLO              |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RPAD(str, length, padStr)</code>：在字符串右侧用 padStr 将原字符串填充至指定长度，当指定长度小于原字符串长度时，截断原字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT RPAD('HELLO', 8, '!');</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| RPAD('HELLO', 8, '!') |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| HELLO!!!              |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>REPEAT(str, times)</code>：按照指定次数重复字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT REPEAT('LA', 3);</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEAT('LA', 3) |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| LALALA          |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>REPLACE(str, from_str, to_str)</code>：将字符串中的所有匹配的字符串替换为新字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT REPLACE('LALALA', 'L', 'B');</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| <span class="keyword">REPLACE</span>(<span class="string">'LALALA'</span>, <span class="string">'L'</span>, <span class="string">'B'</span>) |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| BABABA                      |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>REVERSE(str)</code>：将字符串逆序输出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT REVERSE('ABC');</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| REVERSE('ABC') |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| CBA            |</span><br><span class="line">+<span class="comment">----------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常用日期和时间处理函数"><a href="#常用日期和时间处理函数" class="headerlink" title="常用日期和时间处理函数"></a>常用日期和时间处理函数</h2><ul>
<li><p><code>NOW()</code>：返回当前的时间和日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| NOW()               |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2019-03-25 18:01:47 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CURDATE()</code>：返回当前的日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CURDATE();</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| CURDATE()  |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| 2019-03-25 |</span><br><span class="line">+<span class="comment">------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CURTIME()</code>：返回当前时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CURTIME();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| CURTIME() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 18:05:02  |</span><br><span class="line">+<span class="comment">-----------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DATE(dateAndTime)</code>：提取日期时间表达式中的日期部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATE(NOW());</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| DATE(NOW()) |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| 2019-03-25  |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DAY()</code>：返回日期时间表达式中的天数部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DAY(NOW());</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| DAY(NOW()) |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">|         25 |</span><br><span class="line">+<span class="comment">------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>YEAR()</code>：返回日期时间表达式中的年部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT YEAR(NOW());</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| YEAR(NOW()) |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|        2019 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>EXTRACT(unit FROM date)</code>：按照指定的时间单位从日期时间表达式中提取年、月、日、时间等部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT EXTRACT(YEAR FROM NOW());</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| EXTRACT(YEAR FROM NOW()) |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">|                     2019 |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXTRACT(WEEK FROM NOW());</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| EXTRACT(WEEK FROM NOW()) |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">|                       12 |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXTRACT(HOUR_MICROSECOND FROM NOW());</span><br><span class="line">+<span class="comment">--------------------------------------+</span></span><br><span class="line">| EXTRACT(HOUR_MICROSECOND FROM NOW()) |</span><br><span class="line">+<span class="comment">--------------------------------------+</span></span><br><span class="line">|                         191218000000 |</span><br><span class="line">+<span class="comment">--------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>时间单位的值可参考<a href="https://dev.mysql.com/doc/refman/8.0/en/expressions.html#temporal-intervals" target="_blank" rel="noopener">Temporal Intervals</a>文档</p>
</li>
<li><p><code>DATE_FORMAT(date, format)</code>：按照指定格式显示时间日期</p>
<p>可选的格式可参考<a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format" target="_blank" rel="noopener">Date and time functions</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATE_FORMAT(NOW(), '%W %M %Y');</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| DATE_FORMAT(NOW(), '%W %M %Y') |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| Monday March 2019              |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DATE_ADD(date, INTERVAL exp unit)</code>、<code>DATE_SUB(date, INTERVAL exp unit)</code>：日期和时间的加减操作。返回值是否包含时间取决于给定的时间日期的表达式和时间单位。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATE_ADD('2018-03-25', INTERVAL 1 DAY);</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| DATE_ADD('2018-03-25', INTERVAL 1 DAY) |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| 2018-03-26                             |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT DATE_SUB('2018-03-25 19:26:47', INTERVAL 1 HOUR);</span><br><span class="line">+<span class="comment">--------------------------------------------------+</span></span><br><span class="line">| DATE_SUB('2018-03-25 19:26:47', INTERVAL 1 HOUR) |</span><br><span class="line">+<span class="comment">--------------------------------------------------+</span></span><br><span class="line">| 2018-03-25 18:26:47                              |</span><br><span class="line">+<span class="comment">--------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DATEDIFF(date1, date2)</code>：返回两个日期的差值，会忽略表达式中的时间，仅对日期进行运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATEDIFF('2018-4-30', NOW());</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line">| DATEDIFF('2018-4-30', NOW()) |</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line">|                         -329 |</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ADDDATE(date, INTERVAL exp unit)</code>：等同于<code>DATE_ADD()</code></p>
<p><code>ADDDATE(date, days)</code>：在给定的日期上加上给定的天数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ADDDATE(NOW(), 31);</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ADDDATE(NOW(), 31)  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2019-04-25 19:39:53 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ADDTIME(time1, time2)</code>：将两个时间表达式相加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ADDTIME('10:33:24', '22:23:22');</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| ADDTIME('10:33:24', '22:23:22') |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| 32:56:46                        |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的JSON数据类型</title>
    <url>/2019/03/25/MySQL%E4%B8%AD%E7%9A%84JSON%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>MySQL 支持原生<code>JSON</code>类型，使用<code>JSON</code>数据类型相较于将 JSON 格式的字符串存储在 String 型中的优势有：</p>
<ul>
<li><p>存储时会自动验证 JSON 文本；</p>
</li>
<li><p>可以优化存储格式。存储在<code>JSON</code>型中的 JSON 文本会被转换成一个支持快速读取的文档元素，这样在使用时不需要再解析文本，并且可以直接通过键和索引访问其中的子对象而无需读取全部文本。</p>
</li>
</ul>
<p><code>JSON</code>型中可存储的 JSON 文本的大小不会超过<code>mysql.ini</code>配置文件中设置的<code>max_allowed_packet</code>的值。</p>
<a id="more"></a>

<h2 id="JSON-值的局部更新"><a href="#JSON-值的局部更新" class="headerlink" title="JSON 值的局部更新"></a>JSON 值的局部更新</h2><p>MySQL 从 8.0 开始支持对<code>JSON</code>型中存储的数据进行局部更新，而不需要清除原有数据并写入新值。</p>
<p>局部更新按照下述规则执行：</p>
<ul>
<li><p>数据列被声明为<code>JSON</code>型</p>
</li>
<li><p><code>UPDATE</code>语句使用<code>JSON_SET()</code>、<code>JSON_REPLACE()</code>、<code>JSON_REMOVE()</code>三个函数实现 JSON 的局部更新</p>
<p>但对该列直接赋值不属于局部更新，例如：<code>UPDATE myTable SET jcon1 = &#39;{&quot;a&quot;: 10, &quot;b&quot;: 25}&#39;</code></p>
<p>局部更新操作可以实现在单个<code>UPDATE</code>语句中更新多个<code>JSON</code>列</p>
</li>
<li><p>局部更新是针对同一列数据的操作，对不同列的操作不属于局部更新，例如：<code>UPDATE myTable SET jcon1 = JSON_SET(jcon2, &#39;$.a&#39;, 100)</code></p>
<p>局部更新中可以使用上述三个函数的嵌套调用形式</p>
</li>
<li><p>局部更新仅将现有 JSON 对象中的数组或子对象替换成新值，但不能给父对象或数组添加新元素</p>
</li>
<li><p>所替换的新值不能比原值占据的存储空间更大，除非上一次更新留下了足够的存储空间</p>
</li>
</ul>
<h2 id="创建-JSON-值"><a href="#创建-JSON-值" class="headerlink" title="创建 JSON 值"></a>创建 JSON 值</h2><ul>
<li><p>JSON 数组：<code>[&quot;abc&quot;, 10, null, true, false]</code></p>
<p>JSON 数组中可以存储数字量、字符串、null、布尔量、时间量</p>
</li>
<li><p>JSON 对象：<code>{&quot;key1&quot;: &quot;value&quot;, &quot;key2&quot;: 10}</code></p>
<p>JSON 对象中的键必须为字符串</p>
</li>
</ul>
<p>JSON 数组和 JSON 对象中可以嵌套子 JSON 数组和对象。</p>
<p>MySQL 中的 JSON 编码格式为<code>CHARSET=utf8mb4 COLLATE=utf8mb4_bin</code>。</p>
<h3 id="使用字符串字面量创建-JSON"><a href="#使用字符串字面量创建-JSON" class="headerlink" title="使用字符串字面量创建 JSON"></a>使用字符串字面量创建 JSON</h3><p>在 MySQL 中 JSON 值按照字符串的形式写入，在要求为 JSON 值的上下文中（例如将值插入<code>JSON</code>列，或调用输入参数为 JSON 的函数）MySQL 会解析该字符串，若不符合 JSON 格式则报错。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_TYPE('["abc", 1]');</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| JSON_TYPE('["abc", 1]') |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| ARRAY                   |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_TYPE('&#123;"a": 1, "b": 2&#125;');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| JSON_TYPE('&#123;"a": 1, "b": 2&#125;') |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| OBJECT                        |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_TYPE('"abc"');</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| JSON_TYPE('"abc"') |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| STRING             |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_TYPE('abc');</span><br><span class="line">ERROR 3141 (22032): Invalid JSON text in argument 1 to function json_type: "Invalid value." at position 0.</span><br></pre></td></tr></table></figure>

<h3 id="使用函数创建-JSON"><a href="#使用函数创建-JSON" class="headerlink" title="使用函数创建 JSON"></a>使用函数创建 JSON</h3><p>介绍三个常用的创建 JSON 的函数：</p>
<ul>
<li><p><code>JSON_ARRAY()</code>函数会将传入其中的参数组成 JSON 数组，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_ARRAY('a', 1, NOW());</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| JSON_ARRAY('a', 1, NOW())              |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| ["a", 1, "2019-03-22 10:01:53.000000"] |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_OBJECT()</code>会将传入的键值对转换为 JSON 对象，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_OBJECT('a', 1, 'b', 2);</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| JSON_OBJECT('a', 1, 'b', 2) |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| &#123;"a": 1, "b": 2&#125;            |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_MERGE_PRESERVE()</code>将多个 JSON 文本组合成一个 JSON，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PRESERVE(&#39;[&quot;a&quot;, 1]&#39;, &#39;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#39;);</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">| JSON_MERGE_PRESERVE(&#39;[&quot;a&quot;, 1]&#39;, &#39;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#39;) |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">| [&quot;a&quot;, 1, &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;]                          |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_MERGE_PRESERVE(&#39;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#39;, &#39;&#123;&quot;c&quot;: 3, &quot;d&quot;: 4&#125;&#39;);</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| JSON_MERGE_PRESERVE(&#39;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#39;, &#39;&#123;&quot;c&quot;: 3, &quot;d&quot;: 4&#125;&#39;) |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4&#125;                            |</span><br><span class="line">+-------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用-JSON"><a href="#使用-JSON" class="headerlink" title="使用 JSON"></a>使用 JSON</h2><ul>
<li><p>将创建出的 JSON 值赋值给一个自定义的变量时，该 JSON 会被转换成字符串，因此自定义的变量属于字符串类型、而非 JSON 类型，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @j = JSON_OBJECT(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br></pre></td></tr></table></figure>

<p>创建的<code>@j</code>为字符串类型。</p>
</li>
<li><p>JSON 值在进行比较时会区分大小写，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_ARRAY('X') = JSON_ARRAY('x');</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| JSON_ARRAY('X') = JSON_ARRAY('x') |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">|                                 0 |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br></pre></td></tr></table></figure>

<p><code>&#39;x&#39;</code>和`’X’不相等，返回 false（即 0）。</p>
</li>
<li><p>JSON 中的<code>null</code>、<code>true</code>、<code>false</code>字面量必须为小写形式，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_VALID('null'), JSON_VALID('NULL'), JSON_VALID('Null');</span><br><span class="line">+<span class="comment">--------------------+--------------------+--------------------+</span></span><br><span class="line">| JSON_VALID('null') | JSON_VALID('NULL') | JSON_VALID('Null') |</span><br><span class="line">+<span class="comment">--------------------+--------------------+--------------------+</span></span><br><span class="line">|                  1 |                  0 |                  0 |</span><br><span class="line">+<span class="comment">--------------------+--------------------+--------------------+</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>Null</code>和<code>NULL</code>的形式是对 JSON 型来说非法的。</p>
<p><strong>但应注意，SQL 中的<code>null</code>、<code>true</code>、<code>false</code>字面量不区分大小写。</strong></p>
</li>
<li><p>单引号<code>&#39;&#39;</code>和双引号<code>&quot;&quot;</code>的使用：</p>
<ul>
<li><p>使用<code>JSON_OBJECT()</code>等函数创建 JSON 时，字符串中出现的引号需要使用转义字符<code>\</code>来和标记字符串开始结束的引号作区分，否则会报错，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">正确写法：</span><br><span class="line">mysql&gt; INSERT INTO facts VALUES (JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));</span><br><span class="line">Query OK, 1 row affected (0.22 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO facts VALUES (JSON_OBJECT("mascot", "Our mascot is a dolphin named 'Sakila'."));</span><br><span class="line">Query OK, 1 row affected (0.22 sec)</span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line">mysql&gt; INSERT INTO facts VALUES (JSON_OBJECT("mascot2", "Our mascot is a dolphin named "Sakila"."));</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'"."))'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 JSON 对象字面量创建 JSON 时，需要使用两个转义字符<code>\\</code>来指明 MySQL 不需要对引号进行转义，而保留其字面值，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">两种正确写法：</span><br><span class="line">mysql&gt; INSERT INTO facts VALUES ('&#123;"mascot": "Our mascot is a dolphin named \\"Sakila\\"."&#125;');</span><br><span class="line">Query OK, 1 row affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO facts VALUES ('&#123;"mascot": "Our mascot is a dolphin named \'Sakila\'."&#125;');</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">三种错误写法：</span><br><span class="line">mysql&gt; INSERT INTO facts VALUES ('&#123;"mascot": "Our mascot is a dolphin named \"Sakila\"."&#125;');</span><br><span class="line">ERROR 3140 (22032): Invalid JSON text: "Missing a comma or '&#125;' after an object member." at position 43 in value for column 'facts.sentence'.</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO facts VALUES ('&#123;"mascot": "Our mascot is a dolphin named "Sakila"."&#125;');</span><br><span class="line">ERROR 3140 (22032): Invalid JSON text: "Missing a comma or '&#125;' after an object member." at position 43 in value for column 'facts.sentence'.</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO facts VALUES ('&#123;"mascot": "Our mascot is a dolphin named 'Sakila'."&#125;');</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'Sakila'</span>.<span class="string">"&#125;')' at line 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查找 JSON 中某个键对应的值：</p>
<ul>
<li><p>使用<code>-&gt;</code>操作符，返回值会显示为带有包裹引号和转义字符的形式，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT sentence-&gt;"$.mascot" FROM facts;</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| sentence-&gt;"$.mascot"                        |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| "Our mascot is a dolphin named \"Sakila\"." |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>-&gt;&gt;</code>操作符，返回值会显示为无包裹引号和转义字符的形式，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT sentence-&gt;&gt;"$.mascot" FROM facts;</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| sentence-&gt;&gt;"$.mascot"                   |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| Our mascot is a dolphin named "Sakila". |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="JSON-值的标准化、合并、和自动包装"><a href="#JSON-值的标准化、合并、和自动包装" class="headerlink" title="JSON 值的标准化、合并、和自动包装"></a>JSON 值的标准化、合并、和自动包装</h2><h3 id="JSON-值的标准化"><a href="#JSON-值的标准化" class="headerlink" title="JSON 值的标准化"></a>JSON 值的标准化</h3><p>当使用<code>JSON_OBJECT()</code>函数创建 JSON 对象时，传入参数中的重复键会被忽略，即当出现重复键值对时，会对已存在键值对的值进行更新，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_OBJECT('key1', 1, 'key2', 2, 'key1', 10);</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">| JSON_OBJECT('key1', 1, 'key2', 2, 'key1', 10) |</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">| &#123;"key1": 10, "key2": 2&#125;                       |</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>在使用<code>INSERT()</code>函数插入 JSON 对象时，也会忽略重复键，并更新该键对应的值，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t1 (c1 JSON);</span><br><span class="line">mysql&gt; INSERT INTO t1 VALUES</span><br><span class="line">    -&gt; ('&#123;"x": 1, "x": "a"&#125;'),</span><br><span class="line">    -&gt; ('&#123;"x": 1, "x": "a", "x": [1, 2, 3]&#125;');</span><br><span class="line">mysql&gt; SELECT c1 FROM t1;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| c1               |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| &#123;"x": "a"&#125;       |</span><br><span class="line">| &#123;"x": [1, 2, 3]&#125; |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure>

<p>（<strong>注意</strong>：在 8.0.3 之前版本的 MySQL 中，遇到重复出现的键时，不会用新值更新旧值，而仅忽略该键值对）</p>
<h3 id="JSON-值的合并和自动包装"><a href="#JSON-值的合并和自动包装" class="headerlink" title="JSON 值的合并和自动包装"></a>JSON 值的合并和自动包装</h3><ul>
<li>使用<code>JSON_MERGE_PRESERVE()</code>函数合并多个 JSON 值时会保留重复的键</li>
<li>使用<code>JSON_MERGE_PATCH()</code>函数时仅保留重复键的最后一个，即会发生 JSON 的标准化过程</li>
</ul>
<h4 id="合并-JSON-数组"><a href="#合并-JSON-数组" class="headerlink" title="合并 JSON 数组"></a>合并 JSON 数组</h4><ul>
<li><p><code>JSON_MERGE_PRESERVE()</code>函数会将多个数组串联</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PRESERVE('[1, 2]', '["a", "b"]', '["true", "false"]');</span><br><span class="line">+<span class="comment">------------------------------------------------------------------+</span></span><br><span class="line">| JSON_MERGE_PRESERVE('[1, 2]', '["a", "b"]', '["true", "false"]') |</span><br><span class="line">+<span class="comment">------------------------------------------------------------------+</span></span><br><span class="line">| [1, 2, "a", "b", "true", "false"]                                |</span><br><span class="line">+<span class="comment">------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_MERGE_PATCH()</code>函数仅保留传入的最后一个数组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PATCH('[1, 2]', '["a", "b"]', '["true", "false"]');</span><br><span class="line">+<span class="comment">---------------------------------------------------------------+</span></span><br><span class="line">| JSON_MERGE_PATCH('[1, 2]', '["a", "b"]', '["true", "false"]') |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------+</span></span><br><span class="line">| ["true", "false"]                                             |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="合并-JSON-对象"><a href="#合并-JSON-对象" class="headerlink" title="合并 JSON 对象"></a>合并 JSON 对象</h4><ul>
<li><p><code>JSON_MERGE_PRESERVE()</code>函数会将重复键对应的所有值组合成一个数组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PRESERVE('&#123;"a": 1, "b": 2&#125;', '&#123;"a": 10, "c": 3&#125;');</span><br><span class="line">+<span class="comment">--------------------------------------------------------------+</span></span><br><span class="line">| JSON_MERGE_PRESERVE('&#123;"a": 1, "b": 2&#125;', '&#123;"a": 10, "c": 3&#125;') |</span><br><span class="line">+<span class="comment">--------------------------------------------------------------+</span></span><br><span class="line">| &#123;"a": [1, 10], "b": 2, "c": 3&#125;                               |</span><br><span class="line">+<span class="comment">--------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_MERGE_PATCH()</code>函数仅保留最后一个重复键对应的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PATCH('&#123;"a": 1, "b": 2&#125;', '&#123;"a": 10, "c": 3&#125;');</span><br><span class="line">+<span class="comment">-----------------------------------------------------------+</span></span><br><span class="line">| JSON_MERGE_PATCH('&#123;"a": 1, "b": 2&#125;', '&#123;"a": 10, "c": 3&#125;') |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------+</span></span><br><span class="line">| &#123;"a": 10, "b": 2, "c": 3&#125;                                 |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="合并非-JSON-数组或对象的元素"><a href="#合并非-JSON-数组或对象的元素" class="headerlink" title="合并非 JSON 数组或对象的元素"></a>合并非 JSON 数组或对象的元素</h4><p>当待合并的元素既非 JSON 数组也非 JSON 对象时，会将传入的元素自动包装为长度为 1 的 JSON 数组，并按照合并数组的规则合并</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PRESERVE('1', '2');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| JSON_MERGE_PRESERVE('1', '2') |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| [1, 2]                        |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_MERGE_PATCH('1', '2');</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| JSON_MERGE_PATCH('1', '2') |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| 2                          |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="将-JSON-数组和-JSON-对象合并到一起"><a href="#将-JSON-数组和-JSON-对象合并到一起" class="headerlink" title="将 JSON 数组和 JSON 对象合并到一起"></a>将 JSON 数组和 JSON 对象合并到一起</h4><p>当待合并的元素既有 JSON 数组也有 JSON 对象时，会将 JSON 对象自动包装成数组，并按照合并数组的规则合并</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_MERGE_PRESERVE('[1, 2]', '&#123;"a": 1, "b": 2&#125;');</span><br><span class="line">+<span class="comment">---------------------------------------------------+</span></span><br><span class="line">| JSON_MERGE_PRESERVE('[1, 2]', '&#123;"a": 1, "b": 2&#125;') |</span><br><span class="line">+<span class="comment">---------------------------------------------------+</span></span><br><span class="line">| [1, 2, &#123;"a": 1, "b": 2&#125;]                          |</span><br><span class="line">+<span class="comment">---------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_MERGE_PATCH('[1, 2]', '&#123;"a": 1, "b": 2&#125;');</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">| JSON_MERGE_PATCH('[1, 2]', '&#123;"a": 1, "b": 2&#125;') |</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">| &#123;"a": 1, "b": 2&#125;                               |</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="在-JSON-中查找和修改元素"><a href="#在-JSON-中查找和修改元素" class="headerlink" title="在 JSON 中查找和修改元素"></a>在 JSON 中查找和修改元素</h2><p>在 JSON 中查找和修改元素的语法为：<code>$</code>，该符号后跟随需要查找的键名或索引。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p><code>JSON_EXTRACT()</code>函数用于从 JSON 中提取元素，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('&#123;"a": 1, "b": 2&#125;', '$.a');</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('&#123;"a": 1, "b": 2&#125;', '$.a') |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| 1                                       |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_EXTRACT('[1, 2, 3]', '$[2]');</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('[1, 2, 3]', '$[2]') |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| 3                                 |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><ul>
<li><p><code>JSON_SET()</code>函数用于修改 JSON 中对应的元素，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_SET('&#123;"a": 1, "b": 2&#125;', '$.a', 3);</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| JSON_SET('&#123;"a": 1, "b": 2&#125;', '$.a', 3) |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| &#123;"a": 3, "b": 2&#125;                       |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_SET('[1, 2, 3]', '$[2]', 4);</span><br><span class="line">+<span class="comment">----------------------------------+</span></span><br><span class="line">| JSON_SET('[1, 2, 3]', '$[2]', 4) |</span><br><span class="line">+<span class="comment">----------------------------------+</span></span><br><span class="line">| [1, 2, 4]                        |</span><br><span class="line">+<span class="comment">----------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>当路径对应的元素不存在时，会添加新的元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @j = '["a", &#123;"b": [true, false]&#125;, [10, 20]]';</span><br><span class="line">mysql&gt; SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);</span><br><span class="line">+<span class="comment">--------------------------------------------+</span></span><br><span class="line">| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |</span><br><span class="line">+<span class="comment">--------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [1, false]&#125;, [10, 20, 2]]      |</span><br><span class="line">+<span class="comment">--------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_INSERT()</code>函数会给 JSON 添加新的元素，但是不会更改原有元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @j = '["a", &#123;"b": [true, false]&#125;, [10, 20]]';</span><br><span class="line">mysql&gt; SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [true, false]&#125;, [10, 20, 2]]      |</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_REPLACE()</code>函数会修改现有元素，但不会添加新元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @j = '["a", &#123;"b": [true, false]&#125;, [10, 20]]';</span><br><span class="line">mysql&gt; SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [1, false]&#125;, [10, 20]]             |</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON_REMOVE()</code>函数会删除路径对应的元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @j = '["a", &#123;"b": [true, false]&#125;, [10, 20]]';</span><br><span class="line">mysql&gt; SELECT JSON_REMOVE(@j, '$[1].b[0]', '$[2][2]');</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| JSON_REMOVE(@j, '$[1].b[0]', '$[2][2]') |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [false]&#125;, [10, 20]]         |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="路径语法"><a href="#路径语法" class="headerlink" title="路径语法"></a>路径语法</h3><ul>
<li><p>当键名中包含空格时需要用双引号包含键名，即</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('&#123;"a fish": "shark", "a bird": "sparrow"&#125;', '$."a fish"');</span><br><span class="line">+<span class="comment">------------------------------------------------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('&#123;"a fish": "shark", "a bird": "sparrow"&#125;', '$."a fish"') |</span><br><span class="line">+<span class="comment">------------------------------------------------------------------------+</span></span><br><span class="line">| "shark"                                                                |</span><br><span class="line">+<span class="comment">------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当查找不到路径中的元素时，返回 null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('[1, 2, 3]', '$[3]');</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('[1, 2, 3]', '$[3]') |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| NULL                              |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>&#39;$[M to N]&#39;</code>的形式提取出某一范围内的元素，<code>last</code>关键字指代数组中最后一个元素</p>
<p>（但不能用于修改元素）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('[1, 2, 3]', '$[1 to last]');</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('[1, 2, 3]', '$[1 to last]') |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| [2, 3]                                    |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>*</code>和<code>**</code>通配符来提取元素（但不能用于修改元素）</p>
<ul>
<li><p><code>.*</code>表示提取 JSON 对象中所有键的值，并返回一个数组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('&#123;"a": 1, "b": 2&#125;', '$.*');</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('&#123;"a": 1, "b": 2&#125;', '$.*') |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| [1, 2]                                  |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[*]</code>表示提取 JSON 数组中所有元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('[1, 2, 3]', '$[*]');</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('[1, 2, 3]', '$[*]') |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br><span class="line">| [1, 2, 3]                         |</span><br><span class="line">+<span class="comment">-----------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>prefix**suffix</code>表示提取路径以 prefix 开始、以 suffix 结束的元素，其中 prefix 是可选的，但 suffix 是必须的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_EXTRACT('&#123;"a": &#123;"b": 1, "d": 2&#125;, "c": &#123;"b": 3, "d": 4&#125;&#125;', '$**.b');</span><br><span class="line">+<span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('&#123;"a": &#123;"b": 1, "d": 2&#125;, "c": &#123;"b": 3, "d": 4&#125;&#125;', '$**.b') |</span><br><span class="line">+<span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line">| [1, 3]                                                                  |</span><br><span class="line">+<span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON_EXTRACT('&#123;"a": &#123;"b": 1, "d": 2&#125;, "c": &#123;"b": 3, "d": 4&#125;&#125;', '$.a**.b');</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">| JSON_EXTRACT('&#123;"a": &#123;"b": 1, "d": 2&#125;, "c": &#123;"b": 3, "d": 4&#125;&#125;', '$.a**.b') |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">| [1]                                                                       |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="JSON-值的比较和排序"><a href="#JSON-值的比较和排序" class="headerlink" title="JSON 值的比较和排序"></a>JSON 值的比较和排序</h2><h3 id="JSON-值的比较"><a href="#JSON-值的比较" class="headerlink" title="JSON 值的比较"></a>JSON 值的比较</h3><p>JSON 值使用<code>&lt;</code>、<code>&gt;</code>、<code>=</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&lt;&gt;</code>、<code>&lt;=&gt;</code>、<code>!=</code>操作符进行比较。比较时会将 JSON 转换为 MySQL 的原生数值类型或字符串来比较。</p>
<p>JSON 在比较时分为两步：</p>
<ol>
<li><p>比较 JSON 类型（即<code>JSON_TYPE()</code>的返回值），若类型不同则按照类型的优先级顺序得出比较结果，优先级越高则越大，若类型相同则进行第二步；</p>
<p>JSON 类型的优先级如下：</p>
<p><code>BLOB</code> &lt; <code>BIT</code> &lt; <code>OPAQUE</code> &lt; <code>DATETIME</code> &lt; <code>TIME</code> &lt; <code>DATE</code> &lt; <code>BOOLEAN</code> &lt; <code>ARRAY</code> &lt; <code>OBJECT</code> &lt; <code>STRING</code> &lt; <code>INTEGER</code> = <code>DOUBLE</code> &lt; <code>NULL</code></p>
</li>
<li><p>根据各类型具体的比较规则比较</p>
<ul>
<li><p><code>BLOB</code>、<code>BIT</code>、<code>OPAQUE</code>、<code>STRING</code>：先比较两个值长度相同的部分，如果都相同，则长度较短的值排在长度较长的值之前。对 STRING 的比较是基于 utf8mb4 编码格式的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"a" &lt; "ab" &lt; "b" &lt; "bc"</span><br><span class="line">"A" &lt; "a"</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DATATIME</code>、<code>TIME</code>、<code>DATE</code>：表示较早时间点的值排在表示较晚时间点的值之前。表示相同时间点的 DATATIME 值和 TIMESTAMP 值相等</p>
</li>
<li><p><code>ARRAY</code>：两 JSON 数组长度相同且对应元素相等时两数组相等。长度不同时，对应位置的元素的值较小的数组排在前面；对应元素都相同时，较短的数组排在前面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[] &lt; ["a"] &lt; ["ab"] &lt; ["ab", "cd", "ef"] &lt; ["ab", "ef"]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BOOLEAN</code>：false 值排在 true 值之前</p>
</li>
<li><p><code>OBJECT</code>：当两个 JSON 对象具有相同的键，且各键对应的值也相等时，两个 JSON 对象相等。不相等的 JSON 对象的的排序不定</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;"a": 1, "b": 2&#125; = &#123;"b": 2, "a": 1&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INTEGER</code>、<code>DOUBLE</code>：当两个比较对象一个是 INT 型、一个是 DOUBLE 型时，INT 型会被转换为 DOUBLE 型；但当两个比较对象无法预先判断是 INT 型还是 DOUBLE 型时，会转换为 INT 型比较</p>
</li>
<li><p>JSON 值和 SQL<code>NULL</code>比较时，比较结果未知</p>
</li>
<li><p>JSON 值和非 JSON 值比较时，非 JSON 值会被转换为 JSON 值</p>
</li>
</ul>
</li>
</ol>
<h3 id="JSON-值的排序"><a href="#JSON-值的排序" class="headerlink" title="JSON 值的排序"></a>JSON 值的排序</h3><p>使用<code>ORDER BY</code>和<code>GROUP BY</code>对 JSON 值排序时遵循以下规则：</p>
<ul>
<li>按照前述比较规则排序</li>
<li>升序时，SQL<code>NULL</code>排在所有 JSON 值之前（包括 JSON<code>null</code>）；降序时，SQL<code>NULL</code>排在所有 JSON 值之后</li>
</ul>
<p>推荐将 JSON 值转换为 MySQL 基本类型再进行排序。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/json.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual - 11.6 The JSON Data Type</a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中CHAR和VARCHAR的区别</title>
    <url>/2019/03/21/MySQL%E4%B8%ADCHAR%E5%92%8CVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>CHAR 和 VARCHAR 的主要区别有三方面：</p>
<ul>
<li>最大长度</li>
<li>有效长度</li>
<li>存储方式</li>
<li>是否保留末尾空格</li>
</ul>
<a id="more"></a>

<h2 id="最大长度"><a href="#最大长度" class="headerlink" title="最大长度"></a>最大长度</h2><ul>
<li>CHAR 的长的范围为 0~255</li>
<li>VARCHAR 的长度范围为 0~65535</li>
</ul>
<h2 id="有效长度"><a href="#有效长度" class="headerlink" title="有效长度"></a>有效长度</h2><ul>
<li>CHAR 的长度按照声明的长度保持不变</li>
<li>VARCHAR 的长度是可变的，VARCHAR 数据的有效长度应在声明时指定的长度范围内</li>
<li>当插入的数据超出 CHAR 或 VARCHAR 声明的长度时，非严格模式会报警告并截断数据，严格模式下会报错</li>
<li>当插入的数据超出 CHAR 或 VARCHAR 声明的长度，且当超出的部分仅为数据末尾空格时，无论何种模式下，CHAR 型数据会截断数据且不提示任何信息，而 VARCHAR 型数据会截断数据但报警告</li>
</ul>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ul>
<li><p>CHAR 型数据仅存储数据本身；</p>
<p>VARCHAR 型数据的存储方式为：1~2 字节的长度前缀 + 数据；</p>
</li>
<li><p>CHAR 型数据存储时，若数据的长度小于声明的长度，则会自动在该数据的右侧用空格补全长度；</p>
<p>VARCHAR 型数据存储时，若数据长度小于声明的长度，不会用空格补全；</p>
</li>
</ul>
<p>以长度为 4 的 CHAR 和 VARCHAR 举例：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">CHAR(4)</th>
<th align="left">所需存储空间</th>
<th align="left">VARCHAR(4)</th>
<th align="left">所需存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘’</td>
<td align="left">‘ ‘</td>
<td align="left">4byte</td>
<td align="left">‘’</td>
<td align="left">1byte</td>
</tr>
<tr>
<td align="left">‘ab’</td>
<td align="left">‘ab ‘</td>
<td align="left">4byte</td>
<td align="left">‘ab’</td>
<td align="left">3byte</td>
</tr>
<tr>
<td align="left">‘abcd’</td>
<td align="left">‘abcd’</td>
<td align="left">4byte</td>
<td align="left">‘abcd’</td>
<td align="left">5byte</td>
</tr>
<tr>
<td align="left">‘abcdefg’</td>
<td align="left">‘abcd’</td>
<td align="left">4byte</td>
<td align="left">‘abcd’</td>
<td align="left">5byte</td>
</tr>
</tbody></table>
<h2 id="是否保留末尾空格"><a href="#是否保留末尾空格" class="headerlink" title="是否保留末尾空格"></a>是否保留末尾空格</h2><ul>
<li><p>CHAR 型数据检索时，会去除数据末尾的所有空格</p>
</li>
<li><p>VARCHAR 型数据检索时，会保留数据末尾的所有空格</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_and_char (v <span class="built_in">VARCHAR</span>(<span class="number">4</span>), c <span class="built_in">CHAR</span>(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> varchar_and_char <span class="keyword">VALUES</span> (<span class="string">'ab  '</span>, <span class="string">'ab  '</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'('</span>, v, <span class="string">')'</span>), <span class="keyword">CONCAT</span>(<span class="string">'('</span>, c, <span class="string">')'</span>) <span class="keyword">FROM</span> varchar_and_char;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1anvjvl6qj20bn02q3ya.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>事务及其处理机制</title>
    <url>/2019/03/20/%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是指作为单个逻辑工作单元执行的一系列操作，可以理解为一系列 SQL 语句的集合。</p>
<h2 id="为什么需要事务"><a href="#为什么需要事务" class="headerlink" title="为什么需要事务"></a>为什么需要事务</h2><p>使用事务可以满足数据的 ACID 属性。</p>
<ul>
<li><p>原子性（Atomicity）：</p>
<p>一个事务中的所有操作要么全部完成、要么全部不完成，不会停留在中间的某个操作中。</p>
<blockquote>
<p>例如：A 对 B 转账，A 账户中的钱减少、B 账户中的钱增加这两个操作必须全部成功、或全部失败。不应该出现其中一方成功的状态。</p>
</blockquote>
<p>在事务执行过程中如果发生错误会回滚到事务开始前的状态，MySQL 会通过日志来保证原子性。</p>
</li>
<li><p>一致性（Consistency）：</p>
<p>可以理解为一个事务提交之后，数据库的状态能满足原本的约束。</p>
<blockquote>
<p>例如：A 要支付 100 元，而 A 的账户中只有 90 元，则该事务执行会失败，数据库回滚至支付之前的状态。其中账户的余额就相当于一个约束，支付事务发生前后必须满足该约束。</p>
</blockquote>
<p>事务执行时如果破坏了数据库的原本约束则该该事务执行会失败，并回滚到事务开始前的状态，以保证一致性。</p>
</li>
<li><p>隔离性（Isolation）：</p>
<p>指对并行事务之间是相互隔离的，一个事务的执行不会受到其他事务的干扰。</p>
<blockquote>
<p>例如：银行统计所有储户账户里的资金总额的过程中，A 往账户里存入 100 元，则该存钱事务提交前后查询事务读取到的数据不同，会引起矛盾。</p>
</blockquote>
<p>MySQL 会通过锁机制来保证隔离性。</p>
</li>
<li><p>持久性（Durability）：</p>
<p>被提交的事务对数据库的修改是永久的，即使中途发生崩溃等情况，在系统恢复后仍会完成被提交的事务对数据库的操作。</p>
<p>MySQL 会通过日志来保证持久性。</p>
</li>
</ul>
<h2 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h2><ul>
<li><code>BEGIN</code>：开始一个事务</li>
<li><code>ROLLBACK</code>：事务回滚</li>
<li><code>COMMIT</code>：提交一个事务</li>
</ul>
<p>例如：</p>
<p>有一个如下的 student 表</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ktpwr7tqj205b024we9.jpg" alt=""></p>
<p>如果使用<code>ROLLBACK</code>则数据库不会被改变，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(<span class="keyword">name</span>, age, sex)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="string">'赵六'</span>, <span class="string">'18'</span>, <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ktpwr7tqj205b024we9.jpg" alt=""></p>
<p>如果执行<code>COMMIT</code>则数据库会被改变：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(<span class="keyword">name</span>, age, sex)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="string">'赵六'</span>, <span class="string">'18'</span>, <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g1ktsxz95gj205902hdfm.jpg" alt=""></p>
<p>且提交过的事务就无法回滚了，即再执行一次<code>ROLLBACK</code>数据库也不会回到最初的状态了。</p>
<h2 id="事务的处理机制"><a href="#事务的处理机制" class="headerlink" title="事务的处理机制"></a>事务的处理机制</h2><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>MySQL 通过日志来实现事务的原子性和持久性，主要有回滚日志和重做日志两类。</p>
<h4 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h4><p>为了保证事务的原子性，MySQL 会通过回滚日志来将数据库恢复到事务开始前的状态。</p>
<p>即事务开始后，MySQL 会先将事务进行的所有修改记录到回滚日志中，再执行修改操作。这样在提交之前可以根据回滚日志进行恢复，可以理解为通过一系列的逆向操作来恢复原有的数据。</p>
<h4 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h4><p>重做日志由两部分组成，一部分是内存中的重做日志缓冲区，另一部分是在磁盘上的重做日志文件。</p>
<p>事务修改数据的流程大致如下：</p>
<blockquote>
<ol>
<li>将数据从磁盘读入内存，并更新内存中缓存的数据</li>
<li>生成一条重做日志并写入重做日志缓存</li>
<li>当事务提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件</li>
<li>将内存中的数据更新到磁盘上</li>
</ol>
</blockquote>
<p>这样，当数据还未修改完但发生了系统崩溃等故障时，系统恢复后 MySQL 会跟据重做日志完成之前未完成的操作。</p>
<h3 id="事务的隔离特性"><a href="#事务的隔离特性" class="headerlink" title="事务的隔离特性"></a>事务的隔离特性</h3><p>如果事务不保证隔离性的话，在一个事务处理过程中可能会发生如下问题：</p>
<ul>
<li>脏读（Dirty Read）：即读取到其他事务还未提交的数据；</li>
<li>不可重复读（Non-Repeatable Read）：即一个事务范围内多次查询的结果不同，即在该事务执行过程中，其他事务提交了数据，进而干扰了该事务的执行；</li>
<li>幻读（Phantom Read）：在一个事务查询过程中，其他事务对数据进行了修改，导致查询结果矛盾。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>。不同级别的特性如下：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITED</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p>一般默认的隔离级别为<code>REPEATABLE READ</code>。</p>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>MySQL 通过给事务加锁来保证并行事务直接的隔离，锁分为共享锁（Shared）和互斥锁（Exclusive）两类。共享锁（也称为读锁）保证读操作可以并发执行互不影响，互斥锁（也称为写锁）保证写操作时不会有其他事务访问相同数据而造成冲突。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/bcc614524024" target="_blank" rel="noopener">理解事务 - MySQL 事务处理机制</a></li>
<li><a href="https://draveness.me/mysql-transaction" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现</a></li>
<li><a href="https://www.zhihu.com/question/31346392?sort=created" target="_blank" rel="noopener">如何理解数据库事务中的一致性的概念？</a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习中一些遗漏的知识点</title>
    <url>/2019/03/16/Java%E5%AD%A6%E4%B9%A0%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%81%97%E6%BC%8F%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>最近回顾 Java 时发现之前遗漏了一些知识点，整理在这里。</p>
<a id="more"></a>

<ul>
<li><p>标识符：指用来定义名称的东西，如类名、函数名、变量名…</p>
</li>
<li><p><code>true</code>、<code>false</code>、<code>null</code>不是关键字</p>
</li>
<li><p>编译器会给成员变量分配默认值，但不会给局部变量分配默认值</p>
</li>
<li><p><code>new</code>一个对象时 JVM 都做了什么？</p>
<ol>
<li>类加载检查</li>
<li>分配内存空间</li>
<li>设置对象基本信息</li>
<li>调用构造函数初始化</li>
</ol>
<p>（参考：<a href="https://blog.csdn.net/Rainnnbow/article/details/52149586" target="_blank" rel="noopener">Java 对象的创建 —— new 之后 JVM 都做了什么？</a>）</p>
</li>
<li><p>处理异常的三种方式：捕获异常、声明异常、抛出异常</p>
</li>
<li><p>异常机制的好处：</p>
<ul>
<li>分离了异常处理的代码与常规代码</li>
<li>将异常传递到了调用栈顶端</li>
<li>对异常的类型进行的归类</li>
</ul>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html" target="_blank" rel="noopener">Advantages of Exceptions</a>）</p>
</li>
<li><p>隐藏静态方法和重写实例方法的区别：</p>
<ul>
<li>被调用的重写实例方法的版本是子类中的版本；</li>
<li>被调用的隐藏静态方法的版本取决于它是从父类还是从子类实现调用的。</li>
</ul>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/override.html" target="_blank" rel="noopener">Overriding and Hiding Methods</a>）</p>
</li>
<li><p>当父类的实例方法与接口的默认方法重名时，子类调用方法时遵循的原则为：</p>
<ul>
<li>实例方法比接口的默认方法优先级更高；</li>
<li>当子类实现的多个接口都继承自同一个父类时，且只有一个接口重写了父类的方法，则被接口重写过的方法优先级更高；</li>
<li>当子类实现的几个接口的方法存在冲突时，必须在子类中指明用哪个方法</li>
</ul>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/override.html" target="_blank" rel="noopener">Overriding and Hiding Methods</a>）</p>
</li>
<li><p>重写的几个规则</p>
<ul>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。</li>
</ul>
<p>（参考：<a href="http://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">Java 重写(Override)与重载(Overload)</a>）</p>
</li>
<li><p>重载的关键点：重载方法时必须改变参数（类型或个数）</p>
<p>（参考：<a href="http://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">Java 重写(Override)与重载(Overload)</a>）</p>
</li>
<li><p>构造函数调用的方法应当定义为<code>final</code>，避免子类重写该方法导致意外的结果</p>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/final.html" target="_blank" rel="noopener">Writing Final Classes and Methods</a>）</p>
</li>
<li><p>抽象类中的抽象方法最好加上<code>abstract</code>修饰符，而接口中的抽象方法不必加<code>abstract</code>修饰符</p>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" target="_blank" rel="noopener">Abstract Methods and Classes</a>）</p>
</li>
<li><p>一个类可以实现多个接口使用关键字 implements ；</p>
<p>一个接口可以继承多个接口使用关键字<code>extends</code>；</p>
<p>一个类可以同时继承一个别的类，而且实现一个或多个接口，但是关键字<code>extends</code>要在前</p>
<p>（参考：<a href="https://www.jianshu.com/p/eb77a2e64fda" target="_blank" rel="noopener">Java 基础 接口和抽象类</a>）</p>
</li>
<li><p>接口如果新增了一个方法则所有实现该接口的类必须实现该方法，否则编译不通过，因此接口最好在定义时尽可能完善。如果确实需要扩展接口的功能，可以通过以下方式：</p>
<ul>
<li>使用一个新接口继承原接口，并在新接口中定义新的方法，这样继承原接口的类可以选择是否改用新的接口</li>
<li>在原接口中定义默认方法或静态方法</li>
</ul>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html" target="_blank" rel="noopener">Evolving Interfaces</a>）</p>
</li>
<li><p>当继承一个具有默认方法的接口时，可以有以下三种方式：</p>
<ul>
<li>若不提及该默认方法，则继承的接口继承了该默认方法</li>
<li>若声明了该默认方法，则该方法成为一个抽象方法，需要实现新接口的类来实现</li>
<li>重写该默认方法，实现新接口的类会调用该重写方法</li>
</ul>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">Default Methods</a>）</p>
</li>
<li><p>可以利用静态方法在接口中定义一些工具方法以简化代码</p>
<p>（参考：<a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">Default Methods</a>）</p>
</li>
<li><p><code>protected</code>关键字不能用于修饰类</p>
<p>（参考：<a href="https://github.com/EasonAndLily/JavaTrainingCamp/blob/master/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/5.%E4%BF%AE%E9%A5%B0%E7%AC%A6.md" target="_blank" rel="noopener">访问控制修饰符</a>）</p>
</li>
<li><p><code>protected</code>的可见性：</p>
<ul>
<li>基类的 protected 成员是包内可见的，并且对子类可见；</li>
<li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的 protected 方法。</li>
</ul>
<p>（参考：<a href="http://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html" target="_blank" rel="noopener">Java protected 关键字详解</a>）</p>
</li>
<li><p>局部变量不能被声明为 static 变量；静态方法不能使用类的非静态变量。</p>
<p>（参考：<a href="https://github.com/EasonAndLily/JavaTrainingCamp/blob/master/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/5.%E4%BF%AE%E9%A5%B0%E7%AC%A6.md" target="_blank" rel="noopener">访问控制修饰符</a>）</p>
</li>
<li><p>将对象（即引用类型变量）传递给方法时，被调用的方法可以更改传递给它的对象的内容，但不能更改对象的地址；</p>
<p>将值类型变量传递给方法时，只传递值类型变量的副本。被调用的方法无法访问其原始值，因此无法更改它。被调用的方法可以更改复制的值。</p>
<p>（参考：<a href="https://www.oreilly.com/library/view/java-8-pocket/9781491901083/ch04.html" target="_blank" rel="noopener">Chapter 4. Reference Types</a>）</p>
</li>
<li><p>String 对象是不可更改的，但 StringBuffer 和 StringBuilder 对象是可修改的</p>
<p>（参考：<a href="https://www.oreilly.com/library/view/java-8-pocket/9781491901083/ch04.html" target="_blank" rel="noopener">Chapter 4. Reference Types</a>）</p>
</li>
<li><p>枚举值既可以使用<code>equals()</code>方法比较也可以使用<code>==</code>比较</p>
<p>（参考：<a href="https://www.oreilly.com/library/view/java-8-pocket/9781491901083/ch04.html" target="_blank" rel="noopener">Chapter 4. Reference Types</a>）</p>
</li>
<li><p>两个重载函数，一个参数为原始类型、另一个为包装类型（如 List 类的<code>remove(index i)</code>和<code>remove(Object o)</code>），在调用这两个函数时不会发生自动装箱。</p>
<p>（参考：<a href="http://www.codeceo.com/article/java-auto-pack-unpack.html" target="_blank" rel="noopener">Java 中的自动装箱与拆箱</a>）</p>
</li>
<li><p>使用<code>==</code>比较两个包装类型时不会发生自动装箱，就是在比较两个对象的地址</p>
<p>（参考：<a href="http://www.codeceo.com/article/java-auto-pack-unpack.html" target="_blank" rel="noopener">Java 中的自动装箱与拆箱</a>）</p>
</li>
<li><p>LinkedHashMap 与 HashMap 的不同之处在于它具有一个包含其所有键值对的双向链表，该链表定义了键值对的迭代排序，通常是插入的顺序。注意如果将以插入过的键值对重新插入 map 中，插入顺序不受影响（因为其插入时会先判断 map 中是否包含了该键值对）。</p>
<p>（参考：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener">LinkedHashMap</a>）</p>
</li>
<li><p>ArrayList 会按照插入顺序维护元素，而 HashMap 中元素默认是无序的。</p>
<p>（参考：<a href="https://beginnersbook.com/2013/12/difference-between-arraylist-and-hashmap-in-java/" target="_blank" rel="noopener">Difference between ArrayList and HashMap in Java</a>）</p>
</li>
<li><p>HashSet 也不保证其内部元素的顺序为插入顺序</p>
<p>（参考：<a href="https://beginnersbook.com/2014/08/hashset-vs-hashmap-java/" target="_blank" rel="noopener">Difference between HashSet and HashMap</a>）</p>
</li>
<li><p>使用泛型的好处：</p>
<ul>
<li>在编译期间有更强的类型检查（保证类型安全）</li>
<li>避免强制类型转换（增加代码可读性并减少出错可能）</li>
<li>提升性能（使类型转换工作全部在编译器中完成）</li>
</ul>
<p>（参考：<a href="https://github.com/EasonAndLily/JavaTrainingCamp/blob/master/JavaSE/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/3.%E6%B3%9B%E5%9E%8B.md" target="_blank" rel="noopener">3. 泛型</a>）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】Java编程学习之反射技术及其应用</title>
    <url>/2019/03/12/%E3%80%90%E8%BD%AC%E3%80%91Java%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>看到一篇关于 Java 中反射技术相关知识总结的很好的文章，但是原文中给出的代码示例由于格式问题不易阅读，本文进行了整理，并修改了部分例子。</p>
<a id="more"></a>

<p>（原文链接：<a href="https://www.jianshu.com/p/2072013aa577" target="_blank" rel="noopener">java 编程学习之反射技术及其应用</a>)</p>
<p>说明：原文中给出的代码示例由于格式问题不易阅读，本文进行了整理，并修改了部分例子。</p>
<p>另，本文未整理“泛型的本质”和“动态代理和 AOP”这两节，这些内容请参考原文。</p>
<hr>
<p>翻阅了很多资料想查看一个比较通俗易懂的关于 Java 反射机制的理解，但是想要从概念中去理解一项技术，可能有点困难，所以先将理论型知识贴出来，后面，慢慢来理解。</p>
<blockquote>
<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p>
</blockquote>
<p>注意：要理解 Java 的反射机制，先要了解以下基本概念：运行时，编译时，编译型，解释型，类加载器，动态加载类。</p>
<h2 id="Class-类的使用"><a href="#Class-类的使用" class="headerlink" title="Class 类的使用"></a>Class 类的使用</h2><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>在 Java 中，每个 class 都有一个相应的 Class 对象。也就是说，当我们编写一个类，编译完成后，在生成的.class 文件中，就会产生一个 Class 对象，用于表示这个类的类型信息。</p>
<h3 id="获取-Class-实例的方式"><a href="#获取-Class-实例的方式" class="headerlink" title="获取 Class 实例的方式"></a>获取 Class 实例的方式</h3><p>不能直接创建 Class 的实例对象，因为 Class 类的构造方法是私有的，只有 jvm 可以去创建，因此获取 Class 实例的几种方式为：</p>
<ul>
<li><p>利用对象调用<code>getClass()</code>方法获取该对象的 Class 实例；</p>
</li>
<li><p>使用 Class 类的静态方法<code>forName()</code>，用类的名字获取一个 Class 实例；</p>
</li>
<li><p>运用<code>.class</code>的方式获取 Class 实例，对于基本数据类型的封装类，还可以采用 TYPE 来获取对应的基本数据类型的 Class 实例；</p>
</li>
<li><p>使用类的加载器 ClassLoader 的<code>loadClass()</code>方法获取一个 Class 实例；</p>
</li>
</ul>
<p>综上所述，其实我们代码中创建的每一个类都是一个对象，只不过它是 Class 类的实例对象，这个对象我们称为该类的类类型。并且一个类只可能是 Class 类的一个实例对象，即获取的类类型是相同的</p>
<p>那么，如何去创建 Class 的实例呢？</p>
<p>首先，过程要理解，源文件经过编译（javac.exe）以后，得到一个或多个<code>.class</code>文件。<code>.class</code>文件经过运行（java.exe）这步，就需要进行类的加载（通过 JVM 的类的加载器），记载到内存中的缓存。每一个放入缓存中的<code>.class</code>文件就是一个 Class 的实例！下面是创建 Class 实例的三种方法。</p>
<p>实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReflectTest reflectTest = <span class="keyword">new</span> ReflectTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类实例的getClass()方法</span></span><br><span class="line">        Class clazz1 = reflectTest.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类的.class</span></span><br><span class="line">        Class clazz2 = ReflectTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Class类的forName()方法</span></span><br><span class="line">        Class clazz3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz3 = Class.forName(<span class="string">"com.william.test.ReflectTest"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        ClassLoader loader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        Class clazz4 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz4 = loader.loadClass(<span class="string">"com.william.test.ReflectTest"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据类类型去创建类的实例"><a href="#根据类类型去创建类的实例" class="headerlink" title="根据类类型去创建类的实例"></a>根据类类型去创建类的实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReflectTest reflectTest1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reflectTest1 = (ReflectTest) clazz1.newInstance();<span class="comment">//需要类有无参的构造方法</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h3><p><code>Class.forName(&quot;类的全称&quot;)</code>表示类的类类型，还代表了动态加载类</p>
<p>区分上面所说的“编译”和“运行”，编译时刻加载类是静态加载类，运行时刻加载类是动态加载类</p>
<p>关于动态加载类的实例代码请参考：<a href="http://www.imooc.com/video/3733" target="_blank" rel="noopener">2-1 Java 动态加载类</a></p>
<h3 id="获取方法信息"><a href="#获取方法信息" class="headerlink" title="获取方法信息"></a>获取方法信息</h3><p>获取方法的信息，主要通过 Method 类数组来接受<code>getMethods()</code>方法的返回值，然后进行遍历解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*打印类的信息，包括类的成员函数，成员变量*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethodMessage</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类的类类型</span></span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line">        System.out.println(<span class="string">"类的名称是："</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Method类，方法对象</span></span><br><span class="line"><span class="comment">         * 一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">         * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment">         * getDeclaredMethods()获取的是所有该类自己声明的方法，不论访问权限 */</span></span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            <span class="comment">//1. 获取注解</span></span><br><span class="line">            Annotation[] ann = methods[i].getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a : ann) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 获取权限修饰符</span></span><br><span class="line">            String str = Modifier.toString(methods[i].getModifiers());</span><br><span class="line">            System.out.print(str + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//3. 得到方法的返回值类型的类类型</span></span><br><span class="line">            Class returnType = methods[i].getReturnType();</span><br><span class="line">            System.out.print(returnType.getName() + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//4. 得到方法的名称</span></span><br><span class="line">            System.out.print(methods[i].getName() + <span class="string">"("</span>);</span><br><span class="line">            <span class="comment">//5.获取参数类型--&gt;得到的是参数列表的类型的类类型</span></span><br><span class="line">            Class[] paramTypes = methods[i].getParameterTypes();</span><br><span class="line">            <span class="comment">//解析数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span> || j == paramTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print(paramTypes[j].getName() + <span class="string">" args"</span> + j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(paramTypes[j].getName() + <span class="string">" args"</span> + j + <span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">")"</span>);</span><br><span class="line">            <span class="comment">//6.获取异常类型</span></span><br><span class="line">            Class[] exps = methods[i].getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exps.length != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">" throws "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; exps.length; k++) &#123;</span><br><span class="line">                System.out.print(exps[k].getName() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[name: "</span> + <span class="keyword">this</span>.name + <span class="string">", age: "</span> + <span class="keyword">this</span>.age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beFriend</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends.add(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"zhang"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        ClassUtil classUtil = <span class="keyword">new</span> ClassUtil();</span><br><span class="line">        ClassUtil.printMethodMessage(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">类的名称是：main.java.company.model.Person</span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beFriend</span><span class="params">(main.java.company.model.Person args0)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取成员变量信息"><a href="#获取成员变量信息" class="headerlink" title="获取成员变量信息"></a>获取成员变量信息</h3><p>获取成员变量的信息，同获取方法的信息类似，只不过使用 Field 类数组来接收<code>getFieldss()</code>方法的返回值，然后进行解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取成员变量*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFieldMessage</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取类的类类型</span></span><br><span class="line">    Class clazz = object.getClass();</span><br><span class="line">    System.out.println(<span class="string">"类的名称是："</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员变量也是对象</span></span><br><span class="line"><span class="comment">     * java.lang.reflect.Field</span></span><br><span class="line"><span class="comment">     * Field类封装了关于成员变量的操作</span></span><br><span class="line"><span class="comment">     * getFields()方法获取的是所有的public的成员变量的信息</span></span><br><span class="line"><span class="comment">     * getDeclaredFields获取的是该类自己声明的成员变量的信息 */</span></span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">//获取每个属性的权限修饰符</span></span><br><span class="line">        <span class="keyword">int</span> i = field.getModifiers();</span><br><span class="line">        String modifier = Modifier.toString(i);</span><br><span class="line">        <span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">        Class fieldType = field.getType();</span><br><span class="line">        String typeName = fieldType.getName();</span><br><span class="line">        <span class="comment">//得到成员变量的名称</span></span><br><span class="line">        String fieldName = field.getName();</span><br><span class="line">        System.out.println(modifier + <span class="string">" "</span>+ typeName + <span class="string">" "</span> + fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"zhang"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        ClassUtil classUtil = <span class="keyword">new</span> ClassUtil();</span><br><span class="line">        ClassUtil.printFieldMessage(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">类的名称是：main.java.company.model.Person</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> java.lang.String name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age</span><br><span class="line"><span class="keyword">private</span> java.util.List friends</span><br></pre></td></tr></table></figure>

<h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取对象的构造函数的信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConMessage</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取类的类类型</span></span><br><span class="line">    Class clazz = object.getClass();</span><br><span class="line">    System.out.println(<span class="string">"类的名称是："</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数也是对象</span></span><br><span class="line"><span class="comment">     * java.lang.Constructor中封装了构造函数的信息</span></span><br><span class="line"><span class="comment">     * getConstructors获取所有的public的构造函数</span></span><br><span class="line"><span class="comment">     * getDeclaredConstructors得到所有的构造函数 */</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">        System.out.print(constructor.getName() + <span class="string">"("</span>);</span><br><span class="line">        <span class="comment">//获取构造函数的参数列表---&gt;得到的是参数列表的类类型</span></span><br><span class="line">        Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class clazz1 : paramTypes) &#123;</span><br><span class="line">            System.out.print(clazz1.getName() + <span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"zhang"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        ClassUtil classUtil = <span class="keyword">new</span> ClassUtil();</span><br><span class="line">        ClassUtil.printConMessage(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">类的名称是：main.java.company.model.Person</span><br><span class="line">main.java.company.model.Person(java.lang.String,<span class="keyword">int</span>,)</span><br></pre></td></tr></table></figure>

<h2 id="方法的反射"><a href="#方法的反射" class="headerlink" title="方法的反射"></a>方法的反射</h2><p>方法的<strong>名称</strong>和方法的<strong>参数列表</strong>才能唯一决定某个方法</p>
<h3 id="方法反射的操作"><a href="#方法反射的操作" class="headerlink" title="方法反射的操作"></a>方法反射的操作</h3><p><code>method.invoke(对象，参数列表)</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"zhang"</span>, <span class="number">23</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">"wang"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        Class clazz = person1.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"beFriend"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Object object = method.invoke(person1, person2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException |</span><br><span class="line">                 IllegalAccessException |</span><br><span class="line">                 InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getFriends());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量的反射"><a href="#成员变量的反射" class="headerlink" title="成员变量的反射"></a>成员变量的反射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class personClass = Class.forName(<span class="string">"main.java.company.model.Person"</span>);</span><br><span class="line">    Object personObject = personClass.newInstance();</span><br><span class="line">    Person person = (Person) personObject;</span><br><span class="line"></span><br><span class="line">    Field name = personClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(person, <span class="string">"li"</span>);</span><br><span class="line"></span><br><span class="line">    Field age = personClass.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">    age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    age.set(person, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException |</span><br><span class="line">         IllegalAccessException |</span><br><span class="line">         InstantiationException |</span><br><span class="line">         NoSuchFieldException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数的反射"><a href="#构造函数的反射" class="headerlink" title="构造函数的反射"></a>构造函数的反射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor constructor = clazz2.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    Person person3 = (Person) constructor.newInstance(<span class="string">"zhao"</span>, <span class="number">19</span>);</span><br><span class="line">    System.out.println(person3);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException |</span><br><span class="line">         IllegalAccessException |</span><br><span class="line">         InstantiationException |</span><br><span class="line">         InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射应用之动态代理"><a href="#反射应用之动态代理" class="headerlink" title="反射应用之动态代理"></a>反射应用之动态代理</h2><p>动态代理是指客户通过代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是被代理类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给被代理的对象实例化，并返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">blind</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通过代理类的对象发起对被重写的方法的调用时，都会转化为对如下的invoke方法的调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//method方法的返回值是returnVal</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(object, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建被代理类对象</span></span><br><span class="line">        SubjectImpl realSubject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">        <span class="comment">//2. 创建一个实现了InvocationHandler接口的类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        <span class="comment">//3. 调用blind()方法，返回一个同样实现了Subject接口的代理类的对象</span></span><br><span class="line">        Object object = handler.blind(realSubject);</span><br><span class="line">        Subject subject = (Subject) object;</span><br><span class="line">        subject.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明，了解动态代理和静态代理的区别，所谓的静态代理，其代理类和目标对象的类在编译期间就确定下来，不利于程序的扩展。即，每一个代理类只能为一个接口服务，也就是说程序开发中会产生很多代理类。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>什么是编译？</strong></p>
<p>答：将原程序翻译成计算机语言，就是二进制代码。在 Java 中是将.java 文件翻译成.class 的字节码</p>
<p><strong>什么是编译时？</strong></p>
<p>答：将原程序翻译成计算机语言的过程中。将.java 翻译为.class 文件的过程</p>
<p><strong>什么是运行时？</strong></p>
<p>答：就是在启动这个程序的时候。在 Java 中是，类加载器加载.class 文件，并交给 JVM 处理</p>
<p><strong>什么是编译型语言？</strong></p>
<p>答：将原程序一次性全部转换为二进制代码，然后执行程序</p>
<p><strong>什么是解释型语言？</strong></p>
<p>答：转换一句，执行一句，Java 是既编译又解释的语言</p>
<p><strong>编译型语言和解释型语言的区别：</strong></p>
<p>答：编译型语言效率高，依赖于编译器，但是跨平台差，解释型的效率低，依赖于解释器，但跨平台强</p>
<p><strong>什么是类加载器？</strong></p>
<p>答：类加载器就是 JVM 中的类装载器，作用就是将编译好的.class 字节码运到检查器进行安全检查的，检查通过后开始解释执行</p>
<p><strong>什么是运行时动态加载类？</strong></p>
<p>答：反射就是可以将一个程序（类）在运行的时候获得该程序（类）的信息的机制，也就是获得在编译期不可能获得的类的信息，因为这些信息是保存在 Class 对象中的，而这个 Class 对象是在程序运行时动态加载的</p>
<p>它就是可以在程序运行的时候动态装载类，查看类的信息，生成对象，或操作生成对象。类在运行的时候，可以得到该类的信息，并且可以动态的修改这些信息，自己能看到自己，跟照镜子一样，class 对象是在运行的时候产生的，通过 class 对象操作类的信息是在运行时进行的，当运行程序的时候，类加载器会加载真正需要的类，什么是真正需要的呢？就是该类真正起作用，如：有该类的对象实例，或该类调用了静态方法属性等。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中equals和==的区别和联系</title>
    <url>/2019/03/11/Java%E4%B8%ADequals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<p>在 Java 中使用<code>equals()</code>和相等操作符<code>==</code>是不一样的，适用于不同数据类型和不同场景</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符=="></a>相等操作符==</h3><ul>
<li><p><code>==</code>是一种操作符，比较左右操作数的值是否相同；</p>
</li>
<li><p>在使用<code>==</code>时要注意左右操作数的可比性，即左右操作数应为相同数据类型或子类和父类的关系，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thr = <span class="keyword">new</span> Thread();</span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"GEEKS"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(thr == obj); <span class="comment">// false（thr与obj可比，因为Thread类是Object类的子类）</span></span><br><span class="line">System.out.println(obj == str); <span class="comment">// false（str与obj可比，因为String类是Object类的子类）</span></span><br><span class="line">System.out.println(thr == str); <span class="comment">// error: incomparable types: Thread and String</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h3><ul>
<li><p><code>equals()</code>是 Object 类的方法，由于 Java 中所有的类都是 Object 类的子类，因而所有的类均继承了<code>equals()</code>方法。Object 中<code>equals()</code>方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即原始的<code>equals()</code>方法使用<code>==</code>操作符比较两对象的地址，但我们可以通过重写<code>equals()</code>方法实现我们所需的比较方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(((People)obj).name) &amp;&amp; <span class="keyword">this</span>.age == ((People)obj).age;</span><br><span class="line">      	<span class="comment">// 即通过比较属性值判断两对象是否相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 例2：String的equals()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 首先判断两个对象的内存地址是否相同</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 判断传入的对象是否为String类型</span></span><br><span class="line">   <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">       String anotherString = (String)anObject;</span><br><span class="line">       <span class="keyword">int</span> n = value.length; <span class="comment">// 获得原字符串长度</span></span><br><span class="line">       <span class="comment">//长度相同的情况下逐一比较 char 数组中的每个元素是否相同</span></span><br><span class="line">       <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">           <span class="keyword">char</span> v1[] = value; <span class="comment">// 获得原字符串存储的字符数组</span></span><br><span class="line">           <span class="keyword">char</span> v2[] = anotherString.value; <span class="comment">// 获得传入字符串存储的字符数组</span></span><br><span class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>equals()</code>方法时需要注意的原则：</p>
<blockquote>
<ul>
<li><p>自反性（reflexive）：对于任意不为 null 的引用值 x，<code>x.equals(x)</code> 一定是 true。</p>
</li>
<li><p>对称性（symmetric）：对于任意不为 null 的引用值 x 和 y ，当且仅当<code>x.equals(y)</code>是 true 时，<code>y.equals(x)</code>也是 true。</p>
</li>
<li><p>传递性（transitive）：对于任意不为 null 的引用值 x、y 和 z，如果 <code>x.equals(y)</code> 是 true，同时 <code>y.equals(z)</code> 是 true，那么<code>x.equals(z)</code>一定是 true。</p>
</li>
<li><p>一致性（consistent）：对于任意不为 null 的引用值 x 和 y，如果用于 equals 比较的对象信息没有被修改的话，多次调用<code>equals()</code>方法返回值应保持一致。</p>
</li>
<li><p>对于任意不为 null 的引用值 x，<code>x.equals(null)</code> 返回 false。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="相等操作符和-equals-方法的区别"><a href="#相等操作符和-equals-方法的区别" class="headerlink" title="相等操作符和 equals 方法的区别"></a>相等操作符和 equals 方法的区别</h2><ol>
<li><p><code>equals()</code>是方法，而<code>==</code>是操作符</p>
</li>
<li><p>基本数据类型的比较使用<code>==</code>，对象的比较推荐使用<code>equals()</code></p>
<ul>
<li>原因是：对象是引用数据类型，对象变量保存的是对象的存储地址，因而使用<code>==</code>比较对象实际上比较的是地址是否相同（即，是否指向同一处内存空间），而使用重写后的<code>equals()</code>方法可以比较两个对象的内容是否相同。</li>
</ul>
<p>例如：String 是一种对象，我们在比较两个字符串时，希望比较的是字符串的内容而非存储的地址，因此 String 类重写了<code>equals()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false：因为s1和s2是两个对象，存储的地址不同</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true：因为s1和s2存储的内容相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">s1 == s2; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer s1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">s1 == s2; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Interger s1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Interger s2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">s1 == s2; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true: 因为通过字符串字面量方式创建String对象时，会将该字符串放入字符串常量池，在给s2赋值时JVM会先在常量池查找，引用存在的值，因而s1和s2的地址是相同的</span></span><br></pre></td></tr></table></figure>

<p>（参考：<a href="https://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/" target="_blank" rel="noopener">Java 中的字符串常量池</a>）</p>
</li>
</ol>
<h2 id="补充：hashcode-方法"><a href="#补充：hashcode-方法" class="headerlink" title="补充：hashcode 方法"></a>补充：hashcode 方法</h2><h3 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h3><ul>
<li><p>概念：哈希算法也称散列算法，其作用是通过特定的运算将对象的键值映射成对象在集合中存储的位置。</p>
</li>
<li><p>用途：利用哈希算法可以根据元素内容获得其存储位置，避免了遍历的操作，方便在集合中查找特定元素。</p>
</li>
<li><p>举例：以一个简单的哈希算法——除留余数法为例。</p>
<p>（除留余数法：将需要存入数组的数除以某个常数（如数组的长度）后，以余数作为索引。）</p>
<p>如，将 323 ，458 ，25 ，340 ，28 ，969， 77 使用「除留余数法」存储在长度为 11 的数组中，则每个数字在数组中存放的位置为：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>77</th>
<th>969</th>
<th></th>
<th>25</th>
<th>323</th>
<th></th>
<th>28</th>
<th>458</th>
<th></th>
<th></th>
<th>340</th>
</tr>
</thead>
<tbody><tr>
<td>索引</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody></table>
<p>需要注意的是，不同元素经过 hash 后可能获得相同的散列值，在这种情况下需要进一步进行散列。</p>
<p>因此可以知道，<strong>不同散列值对应的元素一定是不同的，但不同元素的散列值可能相同</strong>，<strong>利用 hash 算法可以判断元素是否不相等</strong>。</p>
</li>
</ul>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><ul>
<li><p>概念：Java 中的<code>hashCode()</code>方法就是一种哈希算法，它根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值，其返回值为一个 int 型值。</p>
</li>
<li><p><code>Object</code>的<code>hashCode()</code>方法返回的是<code>Object</code>实例的 16 进制地址。</p>
</li>
<li><p><code>hashCode()</code>方法和<code>equals()</code>方法的关系：</p>
<ul>
<li><p><code>hashCode()</code>方法和<code>equals()</code>方法是一套对应的方法</p>
</li>
<li><p>对于两个对象，</p>
<p>如果调用<code>equals()</code>方法得到的结果为 true，则两个对象的<code>hashCode()</code>返回值必定相等；</p>
<p>如果<code>equals()</code>方法得到的结果为 false，则两个对象的<code>hashCode()</code>返回值不一定不同；</p>
<p>如果两个对象的<code>hashCode()</code>返回值不等，则<code>equals()</code>方法得到的结果必定为 false；</p>
<p>如果两个对象的<code>hashCode()</code>返回值相等，则<code>equals()</code>方法得到的结果未知。</p>
</li>
<li><p>原始的<code>hashCode()</code>方法返回的是对象的存储地址，<strong>在重写<code>equals()</code>方法的同时，必须重写<code>hashCode()</code>方法</strong>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 只重写equals()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(((People)obj).name) &amp;&amp; <span class="keyword">this</span>.age == ((People)obj).age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(p1.hashCode()); <span class="comment">// 返回值为p1的地址</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;People, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(p1, <span class="number">1</span>); <span class="comment">// 即指定了p1的索引值为1</span></span><br><span class="line"></span><br><span class="line">      	People p2 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">      	System.out.println(hashMap.get(p2)); <span class="comment">// 输出：null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码期望的输出为“1”，但实际的输出为<code>null</code>，发生上述现象的原因是：p2 对象的存储地址与 p1 不同，由于 People 类中只重写了<code>equals()</code>方法而未重写<code>hashCode()</code>方法，则 hashMap 的 get 方法无法根据 hash 值查找到对应的对象，因而返回<code>null</code>。如果希望上述代码按照期望输出“1”，则需要重写<code>hashCode()</code>方法，<strong>使<code>equals()</code>方法和<code>hashCode()</code>方法在逻辑上保持一致</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.hashCode()*<span class="number">37</span>+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>thenApply()和thenCompose()的异同</title>
    <url>/2019/03/05/thenApply-%E5%92%8CthenCompose-%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><p><code>thenApply()</code>和<code>themCompose()</code>都是用于连接多个<code>CompletableFuture</code>调用，通过类似于流的操作来处理<code>CompletableFutrue</code>的结果</p>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><ul>
<li><p><code>thenApply()</code>接收一个函数作为参数，使用该函数处理上一个<code>CompletableFuture</code>调用的结果，并返回一个具有处理结果的<code>Future</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>).thenApply(string -&gt; string + <span class="string">" world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>thenApply()</code>适用于对<code>CompletableFuture</code>调用的结果进行一些转换。</p>
</li>
<li><p><code>thenCompose()</code>的参数为一个返回<code>CompletableFuture</code>实例的函数，该函数的参数是先前计算步骤的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>).thenCompose(string -&gt; CompletableFuture.supplyAsync(() -&gt; string + <span class="string">" world"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>thenCompose()</code>会将内部的<code>CompletableFuture</code>调用展开来并使用上一个<code>CompletableFutre</code>调用的结果在下一步的<code>CompletableFuture</code>调用中进行运算，因此<code>thenCompose()</code>更适用于多个<code>CompletableFuture</code>调用的连接。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.baeldung.com/java-completablefuture" target="_blank" rel="noopener">Guide To CompletableFuture</a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Runable接口和Thread类实现线程的异同</title>
    <url>/2019/03/05/%E4%BD%BF%E7%94%A8Runable%E6%8E%A5%E5%8F%A3%E5%92%8CThread%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><ul>
<li>在实现 Runable 接口的类和继承 Thread 的类中均需要重写<code>run()</code>方法</li>
<li>在启动线程时均通过调用<code>start()</code>方法来执行<code>run()</code>方法中的语句</li>
</ul>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><ul>
<li><p>Runable 是接口、Thread 是类，使用时语法不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadByRunable</span> <span class="keyword">implements</span> <span class="title">Runable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Thread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runable myThread1 = <span class="keyword">new</span> MyThreadByRunable();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread1, <span class="string">"my_thread_impl_Runable"</span>).start();</span><br><span class="line"></span><br><span class="line">        MyThreadByThread myThread2 = <span class="keyword">new</span> MyThreadByThread(<span class="string">"my_thread_extends_Thread"</span>);</span><br><span class="line">        myThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于 java 单继承的特性，使用 Runable 接口使自定义的线程类具有更好的拓展性，而继承 Thread 类的自定义线程类无法实现其他的继承</p>
</li>
<li><p>使用 Runable 接口易于实现资源共享，而继承 Thread 类不易于实现资源共享</p>
<p>示例 1：使用 Runable 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadByRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"is running, count = "</span> + count--);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable myThread1 = <span class="keyword">new</span> MyThreadByRunable();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread1, <span class="string">"Thread_1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread1, <span class="string">"Thread_2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread1, <span class="string">"Thread_3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>!<img src="http://ww1.sinaimg.cn/large/98792392ly1g0rpmdtfk4j20p404zjre.jpg" alt=""></p>
<p>可以看到三个线程共享了 count 值，因为它们是从同一个实例 myThread1 开启的</p>
</li>
</ul>
<p>示例 2：使用 Thread 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadByThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">" is running, count = "</span> + count--);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadByThread myThread4 = <span class="keyword">new</span> MyThreadByThread(<span class="string">"Thread_4"</span>);</span><br><span class="line">        <span class="comment">// 如果用同一个线程对象开启多个线程会报异常</span></span><br><span class="line">        myThread4.start();</span><br><span class="line">        myThread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g0rptx3za1j20rg02s749.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Thread类来开启多个线程的正确写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadByThread myThread4 = <span class="keyword">new</span> MyThreadByThread(<span class="string">"Thread_4"</span>);</span><br><span class="line">        MyThreadByThread myThread5 = <span class="keyword">new</span> MyThreadByThread(<span class="string">"Thread_5"</span>);</span><br><span class="line">        MyThreadByThread myThread6 = <span class="keyword">new</span> MyThreadByThread(<span class="string">"Thread_6"</span>);</span><br><span class="line">        myThread4.start();</span><br><span class="line">        myThread5.start();</span><br><span class="line">        myThread6.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/98792392ly1g0rpvm7u3pj20s404wmx6.jpg" alt=""></p>
<p>可以看到三个线程并没有共享资源，因为它们必须由不同线程对象开启。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/u010926964/article/details/74962673" target="_blank" rel="noopener">多线程——继承 Thread 类和实现 Runnable 接口的区别</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Optional的orElse()和orElseGet()的区别</title>
    <url>/2019/03/04/Java-Optional%E7%9A%84orElse-%E5%92%8CorElseGet-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>从接受参数、执行过程、性能三个方面总结了一下 orElse()和 orElseGet()的区别</p>
<a id="more"></a>

<h3 id="1-接收的参数不同"><a href="#1-接收的参数不同" class="headerlink" title="1. 接收的参数不同"></a>1. 接收的参数不同</h3><p><code>orElse()</code>方法以一个自定义类型的数据作为参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T t)</span></span></span><br></pre></td></tr></table></figure>

<p><code>orElseGet()</code>方法以一个<code>Supplier</code>类型的数据作为参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-程序的执行过程不同"><a href="#2-程序的执行过程不同" class="headerlink" title="2. 程序的执行过程不同"></a>2. 程序的执行过程不同</h3><p>以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] names = <span class="keyword">new</span> String[]&#123;<span class="string">"zhang"</span>, <span class="string">"wang"</span>, <span class="string">"li"</span>, <span class="string">"zhao"</span>, <span class="string">"wu"</span>&#125;;</span><br><span class="line">    Optional.of(<span class="string">"wang"</span>).orElse(getRandomName(names)); <span class="comment">// 执行该句时会打印"Generating a name..."</span></span><br><span class="line">    Optional.of(<span class="string">"wang"</span>).orElseGet(() -&gt; getRandomName(names));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRandomName</span><span class="params">(String[] names)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Generating a name..."</span>);</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">return</span> names[random.nextInt(<span class="number">5</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码在运行<code>Optional.of(&quot;wang&quot;).orElse(getRandomName(names))</code>时会打印”Generating a name…”，而在运行<code>Optional.of(&quot;wang&quot;).orElseGet(() -&gt; getRandomName(names))</code>时没有任何输出，这说明了<code>orElse()</code>中的函数<code>getRandomName</code>被调用了，而<code>orElseGet()</code>中的 Lambda 表达式没有执行。</p>
<p>产生上述现象的原因是，无论 Optional 对象中的值是否为空，<code>orElse()</code>函数都会执行；而由于<code>orElseGet()</code>中的参数为一个<code>Supplier</code>方法，该方法的特点是仅在必要的时候执行，因此只有在 Optional 对象中的值为空时，<code>orElseGet()</code>中的<code>Supplier</code>方法才会执行。</p>
<h3 id="3-性能差异"><a href="#3-性能差异" class="headerlink" title="3. 性能差异"></a>3. 性能差异</h3><p>由于<code>orElse()</code>和<code>orElseGet()</code>执行过程的差异，<code>orElseGet()</code>方法的执行效率相对而言也更快，这是因为他会跳过不必要的方法调用。</p>
<p>因此，<strong>只有当默认值已经事先定义的情况下，才使用<code>orElse()</code>，否则使用<code>orElseGet()</code>更好</strong>。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.baeldung.com/java-optional-or-else-vs-or-else-get" target="_blank" rel="noopener">Java Optional – orElse() vs orElseGet()</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式和流</title>
    <url>/2019/03/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/</url>
    <content><![CDATA[<p>Java 8 新特性之 Lambda 表达式和流处理</p>
<a id="more"></a>

<h2 id="什么是-Lambda-表达式"><a href="#什么是-Lambda-表达式" class="headerlink" title="什么是 Lambda 表达式"></a>什么是 Lambda 表达式</h2><p>Lambda 表达式是一种简洁的语法形式</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123;</span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">//.............</span></span><br><span class="line">    <span class="keyword">return</span> statementM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>单参数语法：</strong> 当 Lambda 表达式的参数个数只有一个，可以省略小括号</li>
<li><strong>单语句语法：</strong> 当 Lambda 表达式只包含一条语句时，可以省略大括号、return 和语句结尾的分号</li>
<li><strong>方法的引用：</strong> 可以使用<code>Class or instance :: method</code>的形式更简洁的引用方法。</li>
<li>参数类型可以省略</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><p>Lambda 表达式的上下文是包含该表达式的域，因此 Lambda 表达式中的<code>this</code>指向的是包含 Lambda 表达式的类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">useLambda</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String value = <span class="string">"Enclosing scope value"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">scopeExperiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Function&lt;String, String&gt; fn = parameter -&gt; &#123;</span><br><span class="line">            String value = <span class="string">"Lambda value"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value; <span class="comment">// 返回的是"Enclosing scope value"</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量让 Lambda 表达式简洁，能直接看出其想要执行的操作，理想的 Lambda 表达式只有一行</p>
<ul>
<li><p>正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = parameter -&gt; buildString(parameter);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildString</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">"Something "</span> + parameter;</span><br><span class="line">    <span class="comment">//many lines of code</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = parameter -&gt; &#123; String result = <span class="string">"Something "</span> + parameter;</span><br><span class="line">    <span class="comment">//many lines of code</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在 Lambda 表达式中访问非常量的变量会导致编译错误</p>
</li>
</ul>
<h2 id="什么是流？"><a href="#什么是流？" class="headerlink" title="什么是流？"></a>什么是流？</h2><p>流是一系列的对象的流动序列，可以对它们进行顺序或并行操作。</p>
<h2 id="流的特征"><a href="#流的特征" class="headerlink" title="流的特征"></a>流的特征</h2><ul>
<li>流不是一种数据结构，只是一系列对象的序列</li>
<li>流不改变原有的数据结构，只返回每个对象执行某个操作的结果</li>
<li>流的操作分为中间操作（只返回流）和最终操作</li>
</ul>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><h3 id="常用中间操作举例"><a href="#常用中间操作举例" class="headerlink" title="常用中间操作举例"></a>常用中间操作举例</h3><ul>
<li><p><code>map</code>：基于某种规则将集合中的元素映射成另一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合A中每个元素翻倍</span></span><br><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">List&lt;Integer&gt; processedList = list.stream()</span><br><span class="line">    .map(item -&gt; item * <span class="number">2</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filter</code>：基于某种规则对集合中的元素进行筛选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求集合中的偶数</span></span><br><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">List&lt;Integer&gt; evenList = list.stream()</span><br><span class="line">    .filter(item -&gt; <span class="number">0</span> == item % <span class="number">2</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sorted</code>：基于某种规则对集合中的元素排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素从小到大排序</span></span><br><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">List&lt;Integer&gt; sortedList = integers.stream()</span><br><span class="line">    .sorted((a, b) -&gt; a.compareTo(b))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>distinct</code>：去除集合中的重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">List&lt;Integer&gt; unrepeatedList = integers.stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>max</code>和<code>min</code>：求集合中元素的最大值和最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line"><span class="keyword">int</span> maximum = list.stream().max(Comparator.comparing(Integer::valueOf)).get();</span><br><span class="line"><span class="keyword">int</span> minimum = list.stream().min(Comparator.comparing(Integer::valueOf)).get();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="常用最终操作举例"><a href="#常用最终操作举例" class="headerlink" title="常用最终操作举例"></a>常用最终操作举例</h3><ul>
<li><p><code>collect</code>：由中间操作的结果创建集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; evenList = list.stream()</span><br><span class="line">    .filter(item -&gt; <span class="number">0</span> == item % <span class="number">2</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach</code>：对流中的每个元素进行某种操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印集合中的所有元素</span></span><br><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduce</code>：对流中的每个元素累计操作，返回累计结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求集合中所有元素的和</span></span><br><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line"><span class="keyword">int</span> summary = list.stream().reduce(<span class="number">0</span>, (acc, cur) -&gt; acc + cur);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.baeldung.com/java-8-lambda-expressions-tips" target="_blank" rel="noopener">Lambda Expressions and Functional Interfaces: Tips and Best Practices</a></li>
<li><a href="https://www.geeksforgeeks.org/stream-in-java/" target="_blank" rel="noopener">Stream In Java</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Externalizable的用法</title>
    <url>/2019/02/26/Externalizable%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>总结了 Java 中 Externalizable 接口的使用方法</p>
<ol>
<li>序列化与反序列化</li>
<li>Externalizable 接口和 Serializable 接口的区别</li>
</ol>
<a id="more"></a>

<p>实现了 Externalizable 接口的类需要重写<code>wirteExternal()</code>方法和<code>readExternal()</code>方法，，这样可以实现自定义方式的序列化和反序列化，而不受限于 JVM。</p>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><ul>
<li><p>语法：</p>
<ul>
<li><p>类实现 Externalizable 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为类添加表示序列化版本号的静态变量，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID；</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>wirteExternal()</code>方法和<code>readExternal()</code>方法，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立文件流并对该类的实例对象调用<code>writeExternal()</code>方法和<code>readExternal()</code>方法，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object.writeExternal(objectOutputStream);</span><br><span class="line">object.readExternal(objectInputStream);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例：</p>
<p>实现 Externalizable 的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(<span class="keyword">this</span>.name);</span><br><span class="line">        out.writeInt(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = in.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述类进行序列化和反序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setName(<span class="string">"Wang"</span>);</span><br><span class="line">      person.setAge(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 序列化</span></span><br><span class="line">      <span class="keyword">try</span> (ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"./docs/Person.txt"</span>)))) &#123;</span><br><span class="line">          person.writeExternal(objectOutputStream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 反序列化</span></span><br><span class="line">      Person personFromFile = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"./docs/Person.txt"</span>))))&#123;</span><br><span class="line">          personFromFile.readExternal(objectInputStream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(personFromFile.getName().equals(person.getName()) &amp;&amp; personFromFile.getAge() == person.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Externalizable-接口和-Serializable-接口的区别"><a href="#Externalizable-接口和-Serializable-接口的区别" class="headerlink" title="Externalizable 接口和 Serializable 接口的区别"></a>Externalizable 接口和 Serializable 接口的区别</h2><ul>
<li><p>责任差异：</p>
<p>实现 Serializable 接口的类是由 JVM 负责序列化其实例对象的，</p>
<p>而实现 Externalizable 接口的类由编程人员负责序列化和反序列化</p>
</li>
<li><p>使用情况差异</p>
<p>当需要序列化整个对象时，使用 Serializable 接口更方便</p>
<p>当需要序列化部分对象时，使用 Externalizable 接口更方法（它可以更便捷的控制如何序列化对象）</p>
</li>
<li><p>性能差异</p>
<p>Serializable 接口性能较差，而 Externalizable 接口的性能可控</p>
</li>
<li><p>实现自定义序列化方式的差异</p>
<p>在实现 Serializable 接口时，通过给字段添加<code>transient</code>关键字可使 JVM 不序列化该字段，但 JVM 仍会将该字段的默认值加载进文件中</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串拼接操作concat和+的区别</title>
    <url>/2019/02/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9Cconcat%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a += b;</span><br><span class="line">a.concat(b);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>concat</code>只能接收字符串参数，而<code>+</code>操作符在会对其他数据类型做<code>toString()</code>转换再运算</li>
<li>当<code>a</code>为<code>null</code>时，<code>a.concat(b)</code>会抛出<code>NullPointerException</code>异常，但<code>a += b</code>会使用<code>a</code>的默认值进行运算</li>
<li><code>concat</code>速度更快，但在多字符串拼接时<code>+</code>操作符更方便</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类和类的异同</title>
    <url>/2019/02/24/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><ul>
<li><p>枚举类也是类，同样具有成员变量、成员方法、构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week &#123;</span><br><span class="line">  	SUNDAY(<span class="string">"星期日"</span>), MONDAY(<span class="string">"星期一"</span>), TUESDAY(<span class="string">"星期二"</span>), WEDNESDAY(<span class="string">"星期三"</span>), THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>), SATURDAY(<span class="string">"星期六"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String day;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    Week(String day) &#123;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类可以实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week implements Workable &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><ul>
<li><p>枚举类的所有实例(枚举值)必须在枚举类的第一行显式地列出，否则这个枚举类将永远不能产生实例。所有的枚举值都是 public static final 的，列出这些枚举值时，系统会自动添加 public static final 修饰，无需程序员显式添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week &#123;</span><br><span class="line">		<span class="comment">// 枚举值</span></span><br><span class="line">  	SUNDAY(<span class="string">"星期日"</span>), MONDAY(<span class="string">"星期一"</span>), TUESDAY(<span class="string">"星期二"</span>), WEDNESDAY(<span class="string">"星期三"</span>), THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>), SATURDAY(<span class="string">"星期六"</span>);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器只能使用 private 访问修饰符（且默认为 private），所以无法从外部调用构造器，构造器只在构造枚举值时被调用。这样做可以保证数据的安全性，使枚举值一定是由内部定义的，拒绝外部传入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week &#123;</span><br><span class="line">  	SUNDAY(<span class="string">"星期日"</span>), MONDAY(<span class="string">"星期一"</span>), TUESDAY(<span class="string">"星期二"</span>), WEDNESDAY(<span class="string">"星期三"</span>), THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>), SATURDAY(<span class="string">"星期六"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String day;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 默认访问权限为private的构造器</span></span><br><span class="line">    Week(String day) &#123;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类不能再派生子类，也不能再继承其他父类</p>
<p>因为枚举类编译后生成一个 class 并且继承 Enum 类，反编译可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// final关键字限定枚举类不能派生子类，extends意味着枚举类已经继承了Enum类，因而不能继承其他父类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类自动拥有 values（用于获得包含全部枚举类实例的数组） 和 valueOf （返回指定的枚举类实例）方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Week sunday = Week.valueOf(<span class="string">"SUNDAY"</span>); <span class="comment">//返回Week类的SUNDAY实例</span></span><br><span class="line">Week[] days = Week.values(); <span class="comment">// 返回Week的所有枚举值构成的数组，可用于遍历枚举类</span></span><br><span class="line"><span class="keyword">for</span>(Week week : Week.values()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类可以有抽象方法，抽象方法可以由枚举值实现，使枚举值具有自己的特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week &#123;</span><br><span class="line">  SUNDAY &#123;</span><br><span class="line">    <span class="function">String <span class="title">getSituation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Good day!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">getSituation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap用法总结</title>
    <url>/2019/02/21/TreeMap%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>TreeMap 中的元素默认按照 keys 的自然排序排列。</p>
<p>（对 Integer 来说，其自然排序就是数字的升序；对 String 来说，其自然排序就是按照字母表排序）</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li><p><code>TreeMap()</code>：创建一个空 TreeMap，keys 按照自然排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TreeMap(Comparator comparator)</code>：创建一个空 TreeMap，按照指定的 comparator 排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; map &#x3D; new TreeMap&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">map.put(3, &quot;val&quot;);</span><br><span class="line">map.put(2, &quot;val&quot;);</span><br><span class="line">map.put(1, &quot;val&quot;);</span><br><span class="line">map.put(5, &quot;val&quot;);</span><br><span class="line">map.put(4, &quot;val&quot;);</span><br><span class="line">System.out.println(map); &#x2F;&#x2F; &#123;5&#x3D;val, 4&#x3D;val, 3&#x3D;val, 2&#x3D;val, 1&#x3D;val&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TreeMap(Map m)</code>：由给定的 map 创建一个 TreeMap，keys 按照自然排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"val"</span>);</span><br><span class="line">...</span><br><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(map);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TreeMap(SortedMap m)</code>：由给定的有序 map 创建 TreeMap，keys 按照原顺序排序</p>
</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="增添元素"><a href="#增添元素" class="headerlink" title="增添元素"></a>增添元素</h3><ul>
<li><code>V put(K key, V value)</code>：将指定映射放入该 TreeMap 中</li>
<li><code>V putAll(Map map)</code>：将指定 map 放入该 TreeMap 中</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li><code>void clear()</code>：清空 TreeMap 中的所有元素</li>
<li><code>V remove(Object key)</code>：从 TreeMap 中移除指定 key 对应的映射</li>
</ul>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><ul>
<li><code>V replace(K key, V value)</code>：替换指定 key 对应的 value 值</li>
<li><code>boolean replace(K key, V oldValue, V newValue)</code>：当指定 key 的对应的 value 为指定值时，替换该值为新值</li>
</ul>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><ul>
<li><code>boolean containsKey(Object key)</code>：判断该 TreeMap 中是否包含指定 key 的映射</li>
<li><code>boolean containsValue(Object value)</code>：判断该 TreeMap 中是否包含有关指定 value 的映射</li>
<li><code>Map.Entry&lt;K, V&gt; firstEntry()</code>：返回该 TreeMap 的第一个（最小的）映射</li>
<li><code>K firstKey()</code>：返回该 TreeMap 的第一个（最小的）映射的 key</li>
<li><code>Map.Entry&lt;K, V&gt; lastEntry()</code>：返回该 TreeMap 的最后一个（最大的）映射</li>
<li><code>K lastKey()</code>：返回该 TreeMap 的最后一个（最大的）映射的 key</li>
<li><code>v get(K key)</code>：返回指定 key 对应的 value</li>
<li><code>SortedMap&lt;K, V&gt; headMap(K toKey)</code>：返回该 TreeMap 中严格小于指定 key 的映射集合</li>
<li><code>SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey)</code>：返回该 TreeMap 中指定范围的映射集合（大于等于 fromKey，小于 toKey）</li>
</ul>
<h3 id="遍历接口"><a href="#遍历接口" class="headerlink" title="遍历接口"></a>遍历接口</h3><ul>
<li><code>Set&lt;Map&lt;K, V&gt;&gt; entrySet()</code>：返回由该 TreeMap 中的所有映射组成的 Set 对象</li>
<li><code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>：对该 TreeMap 中的每一个映射执行指定操作</li>
<li><code>Collection&lt;V&gt; values()</code>：返回由该 TreeMap 中所有的 values 构成的集合</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><code>Object clone()</code>：返回 TreeMap 实例的浅拷贝</li>
<li><code>Comparator&lt;? super K&gt; comparator()</code>：返回给该 TreeMap 的 keys 排序的 comparator，若为自然排序则返回 null</li>
<li><code>int size()</code>：返回该 TreepMap 中包含的映射的数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">treeMap.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">treeMap.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">treeMap.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">treeMap.put(<span class="number">4</span>, <span class="string">"d"</span>); <span class="comment">// treeMap: &#123;1=a, 2=b, 3=c, 4=d&#125;</span></span><br><span class="line"></span><br><span class="line">treeMap.remove(<span class="number">4</span>); <span class="comment">// treeMap: &#123;1=a, 2=b, 3=c&#125;</span></span><br><span class="line"><span class="keyword">int</span> sizeOfTreeMap = treeMap.size(); <span class="comment">// sizeOfTreeMap: 3</span></span><br><span class="line"></span><br><span class="line">treeMap.replace(<span class="number">2</span>, <span class="string">"e"</span>); <span class="comment">// treeMap: &#123;1=a, 2=e, 3=c&#125;</span></span><br><span class="line"></span><br><span class="line">Map.Entry entry = treeMap.firstEntry(); <span class="comment">// entry: 1 -&gt; a</span></span><br><span class="line">Integer key = treeMap.firstKey(); <span class="comment">// key: 1</span></span><br><span class="line">entry = treeMap.lastEntry(); <span class="comment">// entry: 3 -&gt; c</span></span><br><span class="line">key = treeMap.lastKey(); <span class="comment">// key: 3</span></span><br><span class="line">String value = treeMap.get(<span class="number">3</span>); <span class="comment">// value: c</span></span><br><span class="line">SortedMap sortedMap = treeMap.headMap(<span class="number">2</span>); <span class="comment">// sortedMap: &#123;1=a&#125;</span></span><br><span class="line">sortedMap = treeMap.subMap(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// sortedMap: &#123;1=a, 2=e&#125;</span></span><br><span class="line"></span><br><span class="line">Set setOfEntry = treeMap.entrySet(); <span class="comment">// setOfEntry: [1=a, 2=e, 3=c]</span></span><br><span class="line">Collection&lt;String&gt; values = treeMap.values(); <span class="comment">// values: [a, e, c]</span></span><br><span class="line">treeMap.forEach((integer, s) -&gt; System.out.println(integer + <span class="string">"-&gt;"</span> + s));</span><br><span class="line"><span class="comment">// output：</span></span><br><span class="line"><span class="comment">// 1 -&gt; a</span></span><br><span class="line"><span class="comment">// 2 -&gt; e</span></span><br><span class="line"><span class="comment">// 3 -&gt; c</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ul>
<li><p>for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry entry : treeMap.entrySet()) &#123;</span><br><span class="line">		System.out.println(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = treeMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="补充：如何选择合适的-Map"><a href="#补充：如何选择合适的-Map" class="headerlink" title="补充：如何选择合适的 Map"></a>补充：如何选择合适的 Map</h2><ul>
<li>HashMap 可实现快速存储和检索，但其缺点是其包含的元素是无序的，这导致它在存在大量迭代的情况下表现不佳。</li>
<li>LinkedHashMap 保留了 HashMap 的优势，且其包含的元素是有序的。它在有大量迭代的情况下表现更好。</li>
<li>TreeMap 能便捷的实现对其内部元素的各种排序，但其一般性能比前两种 map 差。</li>
</ul>
<p><strong>LinkedHashMap 映射减少了 HashMap 排序中的混乱，且不会导致 TreeMap 的性能损失。</strong></p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener">Class TreeMap&lt;K,V&gt;</a></li>
<li><a href="https://www.baeldung.com/java-treemap" target="_blank" rel="noopener">A Guide to TreeMap in Java</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList用法总结</title>
    <url>/2019/02/20/LinkedList%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>双链表可以从头部或尾部双向遍历。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li><p><code>LinkedList()</code>：创建一个空链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinkedList(Collection c)</code>：由给定集合创建一个链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;(list);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="增添元素"><a href="#增添元素" class="headerlink" title="增添元素"></a>增添元素</h3><ul>
<li><code>boolean add(E e)</code>：将指定元素添加到链表末尾</li>
<li><code>void add(int index, E e)</code>：将指定元素插入到链表的指定位置</li>
<li><code>boolean addAll(Collection c)</code>：将指定集合中的所有元素添加到链表末尾</li>
<li><code>boolean addAll(int index, Collection c)</code>：将指定集合中的所有元素从指定位置开始插入链表</li>
<li><code>void addFirst(E e)</code>：将指定元素插入到链表的开始</li>
<li><code>void addLast(E e)</code>：将指定元素添加到链表的末尾</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li><code>void clear()</code>：移除链表中的所有元素</li>
<li><code>E remove()</code>：移除链表的第一个元素，并返回该元素</li>
<li><code>E remove(int index)</code>：移除链表中指定位置处的元素，并返回该元素</li>
<li><code>boolean remove(E e)</code>：若元素存在则从链表中该元素第一次出现的位置移除该元素</li>
<li><code>E removeFirst()</code>：移除链表的第一个元素，并返回该元素</li>
<li><code>boolean removeFirstOccourence(E e)</code>：从链表中移除指定元素第一次出现位置处的元素（以正序遍历）</li>
<li><code>E removeLast()</code>：移除链表最后一个元素，并返回该元素</li>
<li><code>boolean removeLastOccourence(E e)</code>：从链表中移除指定元素最后一次出现位置处的元素（以正序遍历）</li>
</ul>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><ul>
<li><code>boolean contains(E e)</code>：判断链表中是否存在指定元素</li>
<li><code>E get(int index)</code>：返回链表中指定位置的元素</li>
<li><code>E getFirst()</code>：返回链表的第一个元素</li>
<li><code>E getLast()</code>：返回链表的最后一个元素</li>
<li><code>int indexOf(E e)</code>：返回指定元素在链表中第一次出现的位置，若未找到则返回-1</li>
<li><code>int lastIndexOf(E e)</code>：返回指定元素在链表中最后一次出现的位置，若未找到则返回-1</li>
</ul>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><ul>
<li><code>E set(int index, E e)</code>：将链表中指定位置处的元素修改为指定的元素，返回被替换的元素</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><p><code>int size()</code>：返回链表中包含的元素的数量</p>
</li>
<li><p><code>Object clone()</code>：返回该链表的浅拷贝</p>
</li>
<li><p><code>Object[] toArray()</code>：以适当的顺序（从第一个元素到最后一个元素）返回包含此链表中所有元素的数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// linkedList: []</span></span><br><span class="line"><span class="keyword">boolean</span> result = linkedList.add(<span class="string">"a"</span>); <span class="comment">// result: true, linkedList: ["a"]</span></span><br><span class="line">linkedList.addFirst(<span class="string">"z"</span>); <span class="comment">// linkedList: ["z", "a"]</span></span><br><span class="line">linkedList.add(<span class="number">1</span>, <span class="string">"b"</span>); <span class="comment">// linkedList: ["z", "b", "a"]</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line">list.add(<span class="string">"a"</span>); <span class="comment">// list: ["c", "d", "a"]</span></span><br><span class="line">result = linkedList.addAll(list); <span class="comment">// linkedList: ["z", "b", "a", "c", "d", "a"]</span></span><br><span class="line"></span><br><span class="line">String firstElement = linkedList.remove(); <span class="comment">// linkedList: ["b", "a", "c", "d", "a"]</span></span><br><span class="line">String specifiedIndexElement = linkedList.remove(<span class="number">3</span>); <span class="comment">// linkedList: ["b", "a", "c", "a"]</span></span><br><span class="line">result = linkedList.remove(<span class="string">"a"</span>); <span class="comment">// linkedList: ["b", "c", "a"]</span></span><br><span class="line"></span><br><span class="line">result = linkedList.contains(<span class="string">"b"</span>); <span class="comment">// result: true</span></span><br><span class="line">String specifiedElement = linkedList.get(<span class="number">2</span>); <span class="comment">// specifiedElement: "a"</span></span><br><span class="line">String lastElement = linkedList.getLast(); <span class="comment">// lastElement: "a"</span></span><br><span class="line"><span class="keyword">int</span> index = linkedList.indexOf(<span class="string">"b"</span>); <span class="comment">// index: 0</span></span><br><span class="line"></span><br><span class="line">String element = linkedList.set(<span class="number">1</span>, <span class="string">"a"</span>); <span class="comment">// element: "c", linkedList: ["b", "a", "a"]</span></span><br><span class="line"><span class="keyword">int</span> sizeOfLinkedList = linkedList.size(); <span class="comment">// sizeOfLinkedList: 3</span></span><br><span class="line">Object[] elements = linkedList.toArray(); <span class="comment">// 返回长度为3的Object数组</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ul>
<li><p>for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">		System.out.println(linkedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动增强 for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String s : linkedList) &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = linkedList.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象的四大特性</title>
    <url>/2019/02/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>总结面向对象的四大特性：封装、抽象、继承、多态</p>
<a id="more"></a>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</p>
</li>
<li><p>也有包级别的封装，将具有共同特征的类放在一起</p>
</li>
<li><p>好处：</p>
<ul>
<li>增加复用</li>
<li>单一职责，减少变动带来的风险</li>
<li>只能通过规定的方法访问数据。</li>
<li>隐藏类的实例细节，增加安全性、方便修改和实现。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span> age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li><p>将具体的物体的特性抽象出来，是对真实世界的一种描述，用于模拟实际事物的特征和行为</p>
</li>
<li><p>抽象最好的体现就是类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span> age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>子类就是父类</p>
</li>
<li><p>好处：子类拥有父类的所有属性和方法（除了 private 修饰的属性不能拥有）从而实现了实现代码的复用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	privete <span class="keyword">long</span> studentId;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">long</span> studentId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStudentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.studentId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentId</span><span class="params">(<span class="keyword">long</span> studentId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承的方式：</p>
<ul>
<li>普通类继承普通类、继承抽象类、实现接口</li>
<li>抽象类继承普通类、继承抽象类、实现接口</li>
<li>接口继承接口</li>
</ul>
</li>
<li><p>继承的缺点：</p>
<ul>
<li>子类依赖于父类，父类发生改变时子类必须改变</li>
<li>子类会继承一些父类无用的方法，当继承链很长时，子类的方法很臃肿</li>
</ul>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>不同子类的相同属性的值不同、相同方法的实现不同（通过方法的重写）</p>
</li>
<li><p>好处： 避免子类的发展被多态限制</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cry</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Cry</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"喵喵喵"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"汪汪汪"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组</title>
    <url>/2019/02/18/Java%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组是<strong>固定长度</strong>的、存储<strong>相同类型变量</strong>的<strong>有序</strong>集合</p>
<a id="more"></a>

<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar; <span class="comment">// 推荐</span></span><br><span class="line">dataType arrayRefVar[]; <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line">dataType[][] arrayRefVar;</span><br></pre></td></tr></table></figure>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>即指定数组的大小，为数组开辟内存空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line">arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>

<p>arrayRefVar 保存了数组的引用，即数组第一个元素存储的地址</p>
<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ul>
<li><p>for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">		System.out.println(myList[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动增强 for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> element: myList) &#123;</span><br><span class="line">		System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动增强 for 循环时，不能对循环变量赋值</p>
</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p><code>binarySearch</code>：在数组中搜索，若找到则返回索引值，若未找到返回-1</p>
</li>
<li><p><code>equals</code>：比较两个数组</p>
</li>
<li><p><code>fill</code>：以某个值填充数组</p>
</li>
<li><p><code>sort</code>：给数组中的元素排序</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中String类的常用方法</title>
    <url>/2019/02/18/Java%E4%B8%ADString%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>总结 Java 中 String 类的常用方法</p>
<a id="more"></a>

<h2 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo 方法"></a>compareTo 方法</h2><ul>
<li><p>用途：比较两字符串，返回值为整型</p>
</li>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2); <span class="comment">// 取两字符串中较短字符串的长度</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 在上述长度区间内依次对比各字符是否相等</span></span><br><span class="line">  	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">    		<span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">    		<span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">    		<span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">    				<span class="keyword">return</span> c1 - c2; <span class="comment">// 当某位置处两字符串中的字符不相等时，返回不相等字符的ASCII码差值</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2; <span class="comment">// 若上述长度区间内所有字符均相等则返回两字符串长度的差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareToExample</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       String str1 = <span class="string">"String method tutorial"</span>;</span><br><span class="line">       String str2 = <span class="string">"compareTo method example"</span>;</span><br><span class="line">       String str3 = <span class="string">"String method tutorial"</span>;</span><br><span class="line">       String str4 = <span class="string">"String method "</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> var1 = str1.compareTo(str2);</span><br><span class="line">       System.out.println(var1); <span class="comment">// -16（返回字符S和字符c的ASCII码差值：83 - 99）</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> var2 = str1.compareTo(str3);</span><br><span class="line">       System.out.println(var2); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> var3 = str2.compareTo(<span class="string">"compareTo method example"</span>);</span><br><span class="line">       System.out.println(var3); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> var4 = str3.compareTo(str4);</span><br><span class="line">       System.out.println(var4); <span class="comment">// 8（返回两字符串长度差）</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat 方法"></a>concat 方法</h2><ul>
<li><p>用途：拼接字符串，返回值为 String</p>
</li>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length(); <span class="comment">// 获得待拼接字符串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 若传入的字符串长度为0则返回原字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length; <span class="comment">// 获得原字符串的长度</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen); <span class="comment">// 定义一个大小为原字符串和传入字符串长度之和的char数组，并将原字符串存储到该数组中</span></span><br><span class="line">    str.getChars(buf, len); <span class="comment">// 将传入字符串放入char数组存储的原字符串字符之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>); <span class="comment">// 由char数组生成新字符串并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">String s2 = <span class="string">" "</span>;</span><br><span class="line">String s3 = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1.concat(s2).concat(s3);</span><br><span class="line">System.out.println(s4); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h2><ul>
<li><p>用途：比较两字符串是否相同，返回值为布尔值</p>
</li>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 首先判断两个对象的内存地址是否相同</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 判断传入的对象是否为String类型</span></span><br><span class="line">   <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">       String anotherString = (String)anObject;</span><br><span class="line">       <span class="keyword">int</span> n = value.length; <span class="comment">// 获得原字符串长度</span></span><br><span class="line">       <span class="comment">//长度相同的情况下逐一比较 char 数组中的每个元素是否相同</span></span><br><span class="line">       <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">           <span class="keyword">char</span> v1[] = value; <span class="comment">// 获得原字符串存储的字符数组</span></span><br><span class="line">           <span class="keyword">char</span> v2[] = anotherString.value; <span class="comment">// 获得传入字符串存储的字符数组</span></span><br><span class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="equalsIgnoreCase-方法"><a href="#equalsIgnoreCase-方法" class="headerlink" title="equalsIgnoreCase 方法"></a>equalsIgnoreCase 方法</h2><ul>
<li><p>用途：在忽略大小写的前提下比较两字符串是否相同，返回值为布尔值</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"apple);</span></span><br><span class="line"><span class="string">String s2 = new String("</span>Apple<span class="string">");</span></span><br><span class="line"><span class="string">System.out.println(s1.equalsIgnoreCase(s2)); // true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="contentEquals-方法"><a href="#contentEquals-方法" class="headerlink" title="contentEquals 方法"></a>contentEquals 方法</h2><ul>
<li><p>用途：比较字符串和传入的对象的内容是否相同，返回值为布尔值</p>
<ul>
<li>该方法与 equals 和 equalsIgnoreCase 方法的区别在于，equals 和 equalsIgnoreCase 方法首先检查传入的参数是否为字符串再进行比较，而 contentEquals 方法仅比较两者的内容</li>
</ul>
</li>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先判断传入参数的类型，当传入参数为字符串时，使用equals方法比较，当传入参数不为字符串时仅比较传入参数的内容与原字符串是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">               <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(AbstractStringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = sb.getValue();</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != sb.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != v2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"hello world"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s.equals(sb)); <span class="comment">// false</span></span><br><span class="line">System.out.println(s.contentEquals(sb)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h2><ul>
<li><p>用途：用特定符号连接字符串，返回值为字符串</p>
</li>
<li><p>方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为指定的连接符号，其余参数为待连接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter,</span></span></span><br><span class="line"><span class="function"><span class="params">                          CharSequence... elements)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String message = String.join(<span class="string">"-"</span>, <span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"String"</span>); <span class="comment">// This-is-a-String</span></span><br><span class="line"></span><br><span class="line">List list&lt;String&gt; = Arrays.asList(<span class="string">"Steve"</span>, <span class="string">"Rick"</span>, <span class="string">"Peter"</span>, <span class="string">"Abbey"</span>);</span><br><span class="line">String names = String.join(<span class="string">" | "</span>, list); <span class="comment">// Steve | Rick | Peter | Abbey</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h2><ul>
<li><p>用途：用特定符号分割字符串，返回值为字符串数组</p>
</li>
<li><p>方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为正则表达式</span></span><br><span class="line"><span class="comment">// 第二个参数为可选参数，用于指定分割处的子字符串的数量；当其为0时将返回除末尾空字符串外的所有子字符串；当其为负数时将返回全部子字符串</span></span><br><span class="line">String[] split(String regex, <span class="keyword">int</span> limit)</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"bbaaccaa"</span>;</span><br><span class="line">Sting arr1[] = s.split(<span class="string">"a"</span>); <span class="comment">// arr1 = ["bb", "cc", ""]</span></span><br><span class="line">Sting arr2[] = s.split(<span class="string">"a"</span>, <span class="number">1</span>); <span class="comment">// arr2 = ["bb"]</span></span><br><span class="line">String arr3[]= s.split(<span class="string">"a"</span>, -<span class="number">1</span>); <span class="comment">// arr3 = ["bb", "cc", ""]</span></span><br><span class="line">String arr4[]= s.split(<span class="string">"a"</span>, <span class="number">0</span>); <span class="comment">// arr4 = ["bb", "cc"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim 方法"></a>trim 方法</h2><ul>
<li><p>用途：去除字符串首尾的空格，返回值为字符串</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"    How are you??   "</span>);</span><br><span class="line">System.out.println(<span class="string">"String after trim: "</span> + str.trim()); <span class="comment">// How are you??</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty 方法"></a>isEmpty 方法</h2><ul>
<li><p>用途：判断字符串是否为空，返回值为布尔值</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">""</span>;</span><br><span class="line">String str2=<span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1.isEmpty()); <span class="comment">// true</span></span><br><span class="line">System.out.println(str2.isEmpty()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Object类的常用方法</title>
    <url>/2019/02/18/Java%E4%B8%ADObject%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>总结 Java 中 Object 类的常用方法</p>
<a id="more"></a>

<h2 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h2><ul>
<li><p>用途：使自定义对象可复制</p>
</li>
<li><p>使用：在自定义类中实现 Cloneable 接口，并重写 clone 方法</p>
</li>
<li><p>注意事项：当对象的字段存在引用类型时应注意浅拷贝和深拷贝的问题</p>
<ul>
<li>浅拷贝仅复制变量的值，则对于引用字段来说复制了其地址，因而修改 clone 出的对象会影响原对象</li>
<li>深拷贝则会对对象的引用字段实现拷贝</li>
</ul>
</li>
<li><p>举例：</p>
<p><strong>浅拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Professor professor; <span class="comment">// 引用类型字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Professor <span class="title">getProfessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> professor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProfessor</span><span class="params">(Professor professor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.professor = professor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现clone方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowCopy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Professor p1 = <span class="keyword">new</span> Professor();</span><br><span class="line">        p1.setName(<span class="string">"Professor Zhang"</span>);</span><br><span class="line"></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        s1.setName(<span class="string">"xiao ming"</span>);</span><br><span class="line">        s1.setProfessor(p1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Student s2 = (Student) s1.clone(); <span class="comment">// clone</span></span><br><span class="line">            Professor p2 = s2.getProfessor();</span><br><span class="line">            p2.setName(<span class="string">"Professor Li"</span>); <span class="comment">// s1和s2的引用字段指向的是同一个professor对象，修改s2的引用字段会影响s1的引用字段</span></span><br><span class="line">            s2.setProfessor(p2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现clone方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现clone方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        Student newStudent = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        newStudent.professor = (Professor) <span class="keyword">this</span>.professor.clone(); <span class="comment">// 对student对象的引用字段进行clone</span></span><br><span class="line">        <span class="keyword">return</span> newStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h2><ul>
<li><p>用途：比较两个对象</p>
</li>
<li><p>使用：使用由 Object 类继承而来的 equals 方法或在自定义类中重写 equals 方法</p>
<ul>
<li>若不重写，则 equals 方法默认使用==比较对象</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>equals 方法和相等操作符的区别</li>
<li>重写 equals 方法后必须重写 hashCode 方法，二者应在逻辑上保持一致</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(((People)obj).name) &amp;&amp; <span class="keyword">this</span>.age == ((People)obj).age; <span class="comment">// 即通过比较属性值判断两对象是否相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        People p2 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(p1.equals(p2)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h2><ul>
<li><p>用途：将对象的相关信息映射成散列值，用于在集合中快速查找</p>
</li>
<li><p>使用：使用由 Object 继承而来的 hashCode 方法或在自定义类中重写 hashCode 方法</p>
<ul>
<li>若不重写，hashCode 方法默认返回对象的存储地址</li>
</ul>
</li>
<li><p>注意实现：</p>
<ul>
<li>equals 方法和 hashCode 方法的关系</li>
<li>重写 hashCode 方法后必须重写 equals 方法，二者应在逻辑上保持一致</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(((People)obj).name) &amp;&amp; <span class="keyword">this</span>.age == ((People)obj).age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> name.hashCode()*<span class="number">37</span>+age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(p1.hashCode());</span><br><span class="line"></span><br><span class="line">        HashMap&lt;People, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;People, Integer&gt;();</span><br><span class="line">        hashMap.put(p1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap.get(<span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>))); <span class="comment">// 输出：1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass 方法"></a>getClass 方法</h2><ul>
<li><p>用途：获得对象对应的类名</p>
</li>
<li><p>注意事项：getClass 方法和 class 方法的区别</p>
<ul>
<li>getClass 方法类的实例的方法（即获得的是运行时对象所属的类）</li>
<li>class 方法是类的方法（在编译时即可确定）</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.getClass()); <span class="comment">// class A</span></span><br><span class="line">        System.out.println(A<span class="class">.<span class="keyword">class</span>())</span>; <span class="comment">// class A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h2><ul>
<li><p>用途：返回对象的字符串表示</p>
</li>
<li><p>使用：</p>
<ul>
<li><p>Object 的 toString 方法的返回值为类名+@+十六进制的对象的哈希值，等价于：</p>
<p><code>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</code></p>
</li>
<li><p>推荐在自定义类中重写 toString 方法以将对象包含的信息以直观的方式展示</p>
</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">50</span>);</span><br><span class="line">list.add(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">""</span> + i.toString()); <span class="comment">// 50</span></span><br><span class="line">System.out.println(<span class="string">""</span> + list.toString()); <span class="comment">// [50, Hello World]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 例2：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	Student student = <span class="keyword">new</span> Student();</span><br><span class="line">      	student.setName(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">      	student.setAge(<span class="number">20</span>);</span><br><span class="line">      	System.out.println(student.toString()); <span class="comment">// Student [name = Xiao Ming, age = 20]</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>类、抽象类、接口之间的区别</title>
    <url>/2019/02/16/%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="从含义上讲区别"><a href="#从含义上讲区别" class="headerlink" title="从含义上讲区别"></a>从含义上讲区别</h2><ul>
<li><p><strong>类</strong>：可以理解为一个模具，它定义了一个具体对象应该具有的属性和行为，利用类可以创建具有相同属性和行为的多个对象。</p>
<p>如：“老虎”就是一个类，它的皮毛是黄黑相间的（属性），它捕食食草动物（行为）。</p>
</li>
<li><p><strong>抽象类</strong>：抽象类是对多个类具有的共同的属性和行为的提炼，因此抽象类中包含了子类共有的成员变量和方法。抽象类中包含的方法分为两类：</p>
<ul>
<li>子类共有的方法。每个子类对这些方法的实现是相同的，因此抽象类中给出了这些方法的具体的实现，一旦定义好，所有子类均共享该方法。</li>
<li>各子类需要具体实现的抽象方法。每个子类对这些方法实现的方式各不相同，但具有相同的特征（触发条件和结果——即输入和输出），因而这些方法在抽象类中仅有声明、而没有具体实现，由各子类完成具体的实现。</li>
</ul>
<p>如：“猫科动物”就是一个抽象类，该类定义了此类动物擅长攀爬和跳跃、喜欢独居等属性，并具有食肉、捕杀等行为；该类对多种动物的特征进行的抽象总结，需要通过“老虎”、“猫”、“猎豹”等子类来实现，且每个子类具有其特有的属性、并对对上述行为的实现方式各不相同。</p>
</li>
<li><p><strong>接口</strong>：接口可以理解为一种协议（或者说规则），不同于类和抽象类关注类别、接口关注的是行为，它定义了一类行为的规则（即输入和输出）。不同的类可以对接口中定义的行为有不同的实现方式、同一个类也可以实现多个接口。</p>
<p>如：当一个软件被划分为多个模块由不同小组来开发时，每个小组只需要提供自己负责的模块的接口以规定其余模块与自己模块间的交互方式，每个小组也不需要关注其他模块的内部实现。</p>
</li>
</ul>
<h2 id="从语法上讲区别"><a href="#从语法上讲区别" class="headerlink" title="从语法上讲区别"></a>从语法上讲区别</h2><ul>
<li><p><strong>类</strong>：使用<code>class</code>关键字标识</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> member; <span class="comment">// 成员变量</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 方法</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>抽象类</strong>：使用<code>abstract</code>关键字标识抽象类，使用<code>extends</code>关键字继承抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> member; <span class="comment">// 成员变量</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 普通方法</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> abtract <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>; <span class="comment">// 抽象方法，无函数体</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 抽象方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接口</strong>：使用<code>interface</code>关键字标识接口，使用<code>implements</code>关键字实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> member; <span class="comment">// 成员变量必须为public static final，可以省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">method1</span><span class="params">()</span></span>; <span class="comment">// 接口中方法的声明默认访问方式为public，可以省略，无函数体</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 接口的实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>** 接口和抽象类的区别 **</p>
<blockquote>
<ol>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 default 型，其值可以在子类中重新定义，也可以重新赋值。</li>
<li>抽象类中可以有非抽象方法，接口中则不能有非抽象方法。</li>
<li>接口可以省略 abstract 关键字，抽象类不能。</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="从使用上讲区别"><a href="#从使用上讲区别" class="headerlink" title="从使用上讲区别"></a>从使用上讲区别</h2><ul>
<li>接口/类可以继承多个接口以组成新接口、但抽象类只能继承一个抽象类。</li>
<li>Java 的单继承性决定了类只能继承一个类、但可以实现多个接口。因此接口可以使一个类除继承的主类的行为外、还能具有一些其他类具有的行为，实现了类型的多重继承。</li>
<li>抽象类里可以有普通方法，因此在抽象类中添加一个方法，其所有子类均具有了该方法；而若在接口里添加一个新方法，其所有子类需要首先先实现该方法。</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote>
<ul>
<li>在下列情况下，请考虑使用抽象类：<ul>
<li>希望在几个相关的类之间共享代码。</li>
<li>希望继承抽象类的子类们具有许多通用的方法或字段，或者需要除<code>public</code>之外的访问修饰符（例如<code>protected</code>和<code>private</code>）。</li>
<li>希望声明<code>non-static</code>或<code>non-final</code>的字段，以便定义可以改变具有这些属性的对象的状态的方法。</li>
</ul>
</li>
<li>在下列情况下，请考虑使用接口：<ul>
<li>希望不相关的类实现相同的方法。 例如，Comparable 和 Cloneable 接口由许多不相关的类实现。</li>
<li>希望指定特定数据类型的行为，但不关心谁实现其行为。</li>
<li>希望利用类型的多重继承。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="经典设计模式"><a href="#经典设计模式" class="headerlink" title="经典设计模式"></a>经典设计模式</h3><p>缺省适配模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[接口] --&gt; B[抽象类]</span><br><span class="line">B --&gt; C[普通类]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的自动装箱和拆箱机制</title>
    <url>/2019/02/14/Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<ul>
<li>自动装箱：将基本数据类型转换为包装器类型</li>
<li>自动拆箱：将包装器类型转换为基本数据类型</li>
</ul>
<a id="more"></a>

<h2 id="包装器类型"><a href="#包装器类型" class="headerlink" title="包装器类型"></a>包装器类型</h2><p>包装器类型即基本数据类型对应的对象类型，对应关系如下：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>通过将基本类型包装成对象后，扩大了基本类型的操作（即可作为对象操作，如添加至 collection 中），且方便与 String 对象相互转换。</p>
<p>包装器类型的方法有：</p>
<ul>
<li>构造函数：可用于将基本类型转换为包装器类型</li>
<li><code>valueOf()</code>：可用于将基本类型转换为包装器类型</li>
<li><code>byteValue()、shortValue()</code>等<code>xxxValue()</code>方法：可用于将包装器类型转换为基本数据类型</li>
<li><code>parseInt()</code>等<code>parseXxx()</code>方法：可用于将 String 对象转换为基本数据类型</li>
<li><code>toString()</code>方法：由 Object 对象继承而来，用于将包装器类型转换为 String 类型</li>
</ul>
<h2 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h2><p>装箱时编译器调用包装类型的<code>valueOf()</code>方法将基本数据类型转换为包装器类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="comment">// 1. 赋值时会发生自动装箱</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">Integer y = x; <span class="comment">// autoboxing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用方法时会发生自动装箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Integer para)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">test(x); <span class="comment">// autoboxing</span></span><br></pre></td></tr></table></figure>

<h2 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h2><p>拆箱时编译器调用包装器类型的<code>xxxValue()</code>方法将包装器类型转换为基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">Integer x = <span class="keyword">new</span> Interger(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">// unboxing;</span></span><br></pre></td></tr></table></figure>

<h2 id="应注意的问题"><a href="#应注意的问题" class="headerlink" title="应注意的问题"></a>应注意的问题</h2><p>由于包装器类型为对象，在进行比较时用<code>equals()</code>方法，而不要用<code>==</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如：</span></span><br><span class="line">Integer x = <span class="number">1</span>;</span><br><span class="line">Interer y = <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">"x == y : "</span> + (x == y)); <span class="comment">// true，原因是为了节省内存JVM会缓存-128-127的Integer对象，当值在该范围内时，对象会复用，即x和y指向同一个内存空间。</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">200</span>;</span><br><span class="line">y = <span class="number">200</span>;</span><br><span class="line">System.out.println(<span class="string">"x == y : "</span> + (x == y)); <span class="comment">// false，此时值超出范围，不存在对象复用，因而x和y指向不同的内存空间。</span></span><br><span class="line">System.out.println(<span class="string">"x == y : "</span> + (x.equals(y))); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据类型的自动转换和强制转换</title>
    <url>/2019/02/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>自动转换适用于低位数类型向高位数类型的转换<br>强制转换适用于高位类型向低位类型的转换。</p>
<a id="more"></a>

<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>自动转换适用于低位数类型向高位数类型的转换</p>
<p>规则：</p>
<ol>
<li><p>对于算术运算按照下图所示规则转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[byte] --&gt; B[short]</span><br><span class="line">B --&gt; C[int]</span><br><span class="line">C --&gt; D[long]</span><br><span class="line">D --&gt; E[float]</span><br><span class="line">E --&gt; F[double]</span><br><span class="line">G[char] --&gt; C</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于赋值运算：当两种类型兼容时（如整型和浮点型相互兼容），低位类型会自动向高位类型转换</p>
</li>
<li><p>布尔类型不能和其他基本数据类型相互转换</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">long</span> y = x; <span class="comment">// 在赋值时int型自动转换为long型</span></span><br><span class="line"><span class="keyword">double</span> z = x + y; <span class="comment">// 在算术运算时int型先转换为long型再运算，运算结果转换为double型再赋值</span></span><br></pre></td></tr></table></figure>

<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换适用于高位类型向低位类型的转换。</p>
<ul>
<li><p>语法：用<code>()</code>标注需要强制转换成的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = (<span class="keyword">int</span>)<span class="number">34.56</span> + (<span class="keyword">int</span>)<span class="number">11.2</span>; <span class="comment">// x = 45，丢失精度</span></span><br><span class="line"><span class="keyword">byte</span> y = (<span class="keyword">byte</span>)x;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的this和super关键字</title>
    <url>/2019/02/12/Java%E4%B8%AD%E7%9A%84this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<ul>
<li><code>this</code>指向的是当前对象，是当前对象的引用，利用<code>this</code>关键字可以访问当前对象的字段和方法</li>
<li><code>super</code>指向的是父类对象，是父类对象的引用</li>
</ul>
<a id="more"></a>

<h2 id="this-的用法"><a href="#this-的用法" class="headerlink" title="this 的用法"></a>this 的用法</h2><p><code>this</code>指向的是当前对象，是当前对象的引用，利用<code>this</code>关键字可以访问当前对象的字段和方法，其用法为：</p>
<ol>
<li><p>访问当前对象的字段</p>
<p>尤其是形参和当前对象字段同名时，使用<code>this</code>能将二者进行区分</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age; <span class="comment">// 其中，this.age指代Animal的字段、age指代Animal构造函数的形参</span></span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用当前对象的方法</p>
<p>在当前的对象的方法中可以使用<code>this</code>关键字调用该对象的其他方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> initial)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.result = initial;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.result + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">printResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.add()); <span class="comment">// 调用Calc的add()方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用当前对象的构造函数</p>
<p>当对象的构造函数的参数较多时，可以利用<code>this</code>关键字将构造函数进行拆分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String username;</span><br><span class="line">  <span class="keyword">public</span> String password;</span><br><span class="line">  <span class="keyword">public</span> String email;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(username, password); <span class="comment">// 调用另一个构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="super-的用法"><a href="#super-的用法" class="headerlink" title="super 的用法"></a>super 的用法</h2><p><code>super</code>指向的是父类对象，是父类对象的引用，其用法主要有：</p>
<ol>
<li><p>访问父类的字段和方法</p>
<ul>
<li>当子类中的字段和父类同名时，父类中对应的字段会被隐藏（即使两个字段的类型不同）；</li>
<li>当子类重写了父类的方法时，父类中对应的方法会被隐藏。</li>
</ul>
<p>在这两种情况下，如果想在子类中访问父类中的字段和方法可以利用<code>super</code>关键字。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.pintln(<span class="string">"嗷呜"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Cat extends <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">pulic <span class="title">Cat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.cry(); <span class="comment">// 调用父类Animal的cry()方法</span></span><br><span class="line">    System.out.println(<span class="string">"喵呜"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>2) 调用父类的构造函数</p>
<p>   如果父类的构造函数是带参数的，子类需要通过<code>super</code>关键字显式的调用父类的构造函数来继承父类。</p>
<p>   例如：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Cat extends <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(age, weight); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的final关键字</title>
    <url>/2019/01/31/Java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><code>final</code>关键字可以用来修饰变量、方法、类。<br>被声明为<code>final</code>的变量是只读的，如果希望变量在程序运行的过程中保持不变，可将其声明为<code>final</code>，可以与<code>static</code>关键字结合来声明一个常量。<br>被<code>final</code>修饰的方法不可被子类重写，如果不希望子类改变某个方法，则可将其声明为<code>final</code>。例如，Object 类的方法都被声明为<code>final</code>。<br>被<code>final</code>修饰的类不能被继承，例如，String、和 Integer、Float 等不可变类。</p>
<a id="more"></a>

<h2 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a>final 变量</h2><p>被声明为<code>final</code>的变量是只读的，如果希望变量在程序运行的过程中保持不变，可将其声明为<code>final</code>，可以与<code>static</code>关键字结合来声明一个常量，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOAN = <span class="string">"loan"</span>;</span><br><span class="line">LOAN = <span class="keyword">new</span> String(<span class="string">"loan"</span>); <span class="comment">//invalid compilation error</span></span><br></pre></td></tr></table></figure>

<p>如果<code>final</code>修饰的是一个引用类型，则意味着该变量的指向（或者说该变量保存的地址是不变的）但其内部状态（即该地址下存储的内容）是可变的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Geeks"</span>);</span><br><span class="line">sb.append(<span class="string">"ForGeeks"</span>); <span class="comment">// 这是合法的，对数组来说也是如此</span></span><br></pre></td></tr></table></figure>

<p>当变量被<code>final</code>修饰时，变量名应全大写，单词间用下划线分隔。</p>
<p><code>final</code>变量声明后 <strong>必须</strong> 被初始化（但不要求声明后立即初始化），且不能被再次赋值。给<code>final</code>变量初始化的三种方式：</p>
<ul>
<li><p>在声明时初始化</p>
</li>
<li><p>在构造函数或 instance-initializer block 内初始化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> CAPACITY;</span><br><span class="line"><span class="comment">// instance-initializer block;</span></span><br><span class="line">&#123;</span><br><span class="line">	CAPACITY = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 static block 中初始化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EULERCONSTANT;</span><br><span class="line"><span class="comment">// static block</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	EULERCONSTANT = <span class="number">2.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h2><p>被<code>final</code>修饰的方法不可被子类重写，如果不希望子类改变某个方法，则可将其声明为<code>final</code>。例如，Object 类的方法都被声明为<code>final</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonalLoan</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"personal loan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title">PersonalLoan</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"cheap personal loan"</span>; <span class="comment">//compilation error: overridden method is final</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法被声明为<code>final</code>后执行效率更高（在方法较为简单的前提下），因为其在编译时已经静态绑定了，不需要在运行时动态绑定。</p>
<h2 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h2><p>被<code>final</code>修饰的类不能被继承，例如，String、和 Integer、Float 等不可变类。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonalLoan</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title">PersonalLoan</span></span>&#123;  <span class="comment">//compilation error: cannot inherit from final class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，抽象类和接口不能用<code>final</code>修饰，因为抽象类和接口必须被继承。</p>
<h2 id="final-关键字的好处"><a href="#final-关键字的好处" class="headerlink" title="final 关键字的好处"></a>final 关键字的好处</h2><ol>
<li>final 关键字提高了性能。JVM 和 Java 应用都会缓存 final 变量。</li>
<li>final 变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
<li>使用 final 关键字，JVM 会对方法、变量及类进行优化。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的访问控制修饰符</title>
    <url>/2019/01/17/Java%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>访问控制修饰符一共四类：<code>default</code>、<code>public</code>、<code>private</code>、<code>protected</code></p>
<a id="more"></a>

<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><ul>
<li><p>关键字：无。不写访问控制修饰符即为<code>default</code></p>
</li>
<li><p>访问权限：同一包内可见</p>
</li>
<li><p>修饰对象：类、接口、变量、方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg1.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A(); <span class="comment">// 编译不通过：'pkg1.A' is not public in 'pkg1'. Cannot be accessed from outside package</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pkg1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123; <span class="comment">// 该类的访问权限为default</span></span><br><span class="line">  <span class="keyword">int</span> field; <span class="comment">// 该字段访问权限为default</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> aInt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法的访问权限为default</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"method1 is implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; <span class="comment">// 该接口的访问权限为default</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.method(a.field); <span class="comment">// 同包内可以访问权限为default的类、方法、字段</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><ul>
<li>关键字：<code>public</code></li>
<li>访问权限：对所有类可见</li>
<li>修饰对象：类、接口、变量、方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg2.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.method(a.field); <span class="comment">// 所有类均可以访问权限为public的class A</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pkg2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123; <span class="comment">// 该类的访问权限为public</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> field; <span class="comment">// 该字段的访问权限为public</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> aInt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法的访问权限为public</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"method1 is implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; <span class="comment">// 该接口的访问权限为public</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul>
<li>关键字：<code>private</code></li>
<li>访问权限：在同一类内可见</li>
<li>修饰对象：变量、方法，<strong>不能修饰类（外部类）、接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg3.C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    c.method(<span class="number">0</span>); <span class="comment">// 编译不通过：'method()' has private access in 'pkg3.C'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">package</span> pkg3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// 该类为外部类，访问权限不能为private，否则编译不通过</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> field; <span class="comment">// 该字段的访问权限为private</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125; <span class="comment">// 该类为内部类，访问权限可以为private</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法的访问权限为private</span></span><br><span class="line">    System.out.println(<span class="keyword">this</span>.field); <span class="comment">// 类内部可以访问私有字段</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pkg3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">E</span> </span>&#123; <span class="comment">// 编译不通过：Modifier 'private' not allowed here</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><ul>
<li>关键字：<code>protected</code></li>
<li>访问权限：<ul>
<li>基类的 protected 成员是包内可见的，并且对子类可见；</li>
<li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的 protected 方法。</li>
</ul>
</li>
<li>修饰对象：变量、方法。 <strong>不能修饰类（外部类）、接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pkg1.H;</span><br><span class="line"><span class="keyword">import</span> pkg1.K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    F f = <span class="keyword">new</span> F();</span><br><span class="line">    G g = <span class="keyword">new</span> G(); <span class="comment">// 是F类的同包子类</span></span><br><span class="line">    H h = <span class="keyword">new</span> H(); <span class="comment">// 是F类的不同包子类</span></span><br><span class="line"></span><br><span class="line">    f.method();</span><br><span class="line">    g.method(); <span class="comment">// protected方法是包内可见的</span></span><br><span class="line">    h.method(); <span class="comment">// protected方法是对子类可见的</span></span><br><span class="line"></span><br><span class="line">    K k = <span class="keyword">new</span> K();</span><br><span class="line">    k.method(); <span class="comment">// 编译不通过：'method()' has protected access in 'pkg1.K'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">package</span> pkg4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123; <span class="comment">// 该类为外部类，访问权限不能为protected，否则编译不通过</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> field; <span class="comment">// 该字段的访问权限为protected</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法的访问权限为protected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">F</span> </span>&#123;&#125; <span class="comment">// 同包子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">package</span> pkg1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pkg4.F;</span><br><span class="line"><span class="keyword">import</span> pkg4.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">F</span> </span>&#123;&#125; <span class="comment">// 不同包子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">K</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常总结</title>
    <url>/2019/01/11/Java%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>异常是程序运行过程中可能发生的一类事件。</p>
<p>当方法中发生错误时，该方法会创建一个对象——异常对象——并将其交给 runtime system（该过程称为 <strong>抛出异常</strong>）。</p>
<p>异常对象包含了错误信息，包括错误发生时的类型和程序状态。</p>
<p>当异常被抛出时，runtime system 会从调用堆栈里寻找可以处理该异常的方法（exception handler)，当找到合适的 exception handler 时，即称为 catch the exception；如果 runtime system 找不到合适的 exception handler，则程序终止。</p>
<a id="more"></a>

<h2 id="异常的处理与声明规则"><a href="#异常的处理与声明规则" class="headerlink" title="异常的处理与声明规则"></a>异常的处理与声明规则</h2><ul>
<li><p>使用<code>try-catch-finally</code>语句来捕获和处理异常</p>
<ul>
<li><p><code>try</code>块包含可能抛出异常的语句</p>
<p><code>catch</code>块是异常的接收者，用于处理异常</p>
<p><code>finally</code>块包含无论是否发生异常均需要运行的语句</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberFromArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array[index];</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"数组越界异常："</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>try-catch-finally</code>规则：<ul>
<li>必须在 try 之后添加 catch （至少一个）或 finally 块。</li>
<li>必须遵循块顺序：若同时使用 catch 和 finally 块，则顺序为：try-catch-finally</li>
<li>当一个 try 块有多个 catch 时，执行第一个能匹配的块。</li>
<li>可嵌套 try-catch-finally 结构。</li>
<li>在 try-catch-finally 结构中，可重新抛出异常。</li>
<li>除了下列情况，总将执行 finally 做为结束：<ul>
<li>JVM 过早终止（调用 System.exit(int)）；</li>
<li>在 finally 块中抛出一个未处理的异常；</li>
<li>计算机断电、失火、或遭遇病毒攻击。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>throw</code>语句声明异常</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberFromArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; array.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组越界异常"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>throw</code>规则：<ul>
<li>必须声明方法可抛出的任何 checked exception。</li>
<li>error 和 runtime exception 不是必须声明的。</li>
<li>调用方法必须遵循任何 checked exception 的处理和声明规则。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>但并非所有异常都适用于上述规则。</p>
<h2 id="三类异常"><a href="#三类异常" class="headerlink" title="三类异常"></a>三类异常</h2><ul>
<li><p>checked exception</p>
<p>该类异常是可预测、可修复的</p>
<p>如：<code>FileNotFoundException</code>、<code>ArrayIndexOutOfBoundException</code></p>
<p>checked exceptions 适用于前述异常处理与声明规则，该类异常如果没有经过遵循前述规程的 exception handler 处理，则会编译不通过。</p>
</li>
<li><p>error</p>
<p>该类异常是发生于应用程序外部的特例，往往无法预测和修复</p>
<p>如：<code>IOError</code>、<code>OutOfMemoryError</code></p>
<p>errors 不适用于前述异常处理与声明规则</p>
</li>
<li><p>runtime exception</p>
<p>该类异常是发生于应用程序内部的特例，同样难以预测和修复。该类异常通常表示程序存在 bug，例如逻辑 bug 或 API 的不当使用。</p>
<p>如：<code>NullPointerException</code>、<code>ArithmeticException</code></p>
<p>runtime exceptions 不适用于前述异常处理与声明规则</p>
</li>
</ul>
<p>除以上三种类型外，还可以自定义异常。</p>
<h2 id="常见异常举例"><a href="#常见异常举例" class="headerlink" title="常见异常举例"></a>常见异常举例</h2><ul>
<li><p><code>Java.lang.NullPointException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生异常："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 发生异常：null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Java.lang.ClassNotFoundException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"anotherPackage"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生异常："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 发生异常：anotherPackage</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Java.lang.ArithmeticException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> result = a / b;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生异常："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 发生异常：/ by zero</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Java.lang.ArrayIndexOutOfBoundsException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生异常："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 发生异常：4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Java.lang.IllegalArgumentException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> arr = <span class="number">0</span>;</span><br><span class="line">      Array.getLength(arr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生异常："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 发生异常：Argument is not an array</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use IntelliJ IDEA</title>
    <url>/2019/01/10/How-to-use-IntelliJ-IDEA/</url>
    <content><![CDATA[<p>IntelliJ IDEA 快速上手</p>
<a id="more"></a>

<h2 id="Create-a-new-project"><a href="#Create-a-new-project" class="headerlink" title="Create a new project"></a>Create a new project</h2><p>打开 IntelliJ IDEA，点击<code>Create New Project</code></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd3lqsr24j20ln0djglv.jpg" alt=""></p>
<p>配置 SDK，可以点击<code>New...</code>选择其他 SDK，配置好后进入下一步</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd3sjom1dj20k00k13yr.jpg" alt=""></p>
<p>可以根据模板快速创建项目</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd3uk9moij20k00k1jrc.jpg" alt=""></p>
<p>其中，<code>Command Line App</code> 会自动创建一个带有 <code>main</code> 方法的类，<code>Java Hello World</code> 会自动创建一个带有<code>main</code> 方法并能打印 “Hello World” 的类。</p>
<p>进入下一步之后可以修改项目名称、位置</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd40j0y08j20k00k1mx6.jpg" alt=""></p>
<p>点击<code>Finish</code>就完成了项目的创建</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd44dfwfwj211y0k8jsa.jpg" alt=""></p>
<p>界面左侧展示了项目文件结构，在项目文件夹下，<code>.idea</code>中为项目的配置文件，<code>src</code>为源代码；界面右侧为编辑器，里面已经写好了一个包含<code>main</code>方法的类，我们可以在其中写入自己的代码。</p>
<p>点击右上方绿色小三角（或<code>Shift + F10</code>）可以编译并运行程序，界面下方会出现控制台，显示输出结果</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd4d6zj5uj211y0kgjss.jpg" alt=""></p>
<p>点击右上方<code>Main</code>右侧的小三角可以编辑配置信息</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd4ghj5vfj211y0kggn3.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd4ih1h78j20uc0j93z9.jpg" alt=""></p>
<p><code>Program arguments</code>中可以写入项目的参数列表</p>
<p>配置好之后回到主界面，按行号右侧的绿色小三角（或<code>Ctrl + Shift + F10</code>）可以单独运行某个方法。</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>可以在设置中设置选择版本管理工具，如选择 Github，然后配置自己的 Github 账户</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd5eku9zbj20sk0jugmi.jpg" alt=""></p>
<p><code>Alt + F12</code>可以打开终端，并输入 git 指令实现版本管理。</p>
<p>点击菜单栏的<code>VCS</code>可以对新的项目进行版本管理</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd5k77k5bj211y0kgta9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd5llzc2oj20ia04j746.jpg" alt=""></p>
<p>可以根据 URL 将 git 仓库 clone 下来。</p>
<p><code>Alt + 9</code>可以打开版本管理工具，其中的<code>Local Changes</code>标签页显示了更改或新增的文件，并可以进行查看修改或提交等操作</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd5qwnk6lj211y0kgabh.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd5sh6rjij20nq0k8wfj.jpg" alt=""></p>
<p><code>Log</code>标签页可以查看 commit 历史</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fzd5tzikb8j211y0kgabo.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>理解单一职责原则</title>
    <url>/2019/01/08/%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>单一职责原则就是让一个方法 / 类 / 文件只干一件事。</p>
<p>（查了很多相关的资料，都是从类或接口的角度来讲的，不过从我的理解来说，这个职责不仅仅针对这两个维度）</p>
<p>从自己写思沃影院的体会来讲讲理解。</p>
<a id="more"></a>

<h2 id="文件的单一职责原则"><a href="#文件的单一职责原则" class="headerlink" title="文件的单一职责原则"></a>文件的单一职责原则</h2><p>首先这个项目需要完成一个思沃影院的网页，提供查询电影信息的功能。项目包含了 html（即网页布局）、css（样式与布局）、js（业务与展示逻辑）三部分工作。</p>
<p>实际上我们都知道 html 可以通过<code>&lt;style&gt;</code>标签和<code>&lt;script&gt;</code>标签之间将 css 和 js 部分的代码写进 html 里，但是对于一个内容较多且具有较为复杂的逻辑的网页来说，其 html、css、js 部分的代码都可能达到上百行（也许更多），因此这种方式会致使整个 html 体量庞大、难以维护。</p>
<p>因此，更好的做法是通过外部引用来添加 css 和 js，做到 html 文件、css 文件、js 文件只负责其本身需要负责的事情。</p>
<p>同样的，对 css 文件来说，当网页内容较多时，css 代码也是非常多的，如果把整个网页的 css 全部写在一个文件里会给调试与后续维护工作带来不必要的麻烦。</p>
<p>例如思沃影院这个项目包含了主页和详情页两个网页，这两个网页中有一部分元素实际上是相同的，如果能够把相同部分的 css 提取出来作为单独的 css 文件，不仅可以减少重复代码，还方面后续样式的调整。因此我们当时提取了一个<code>basic.css</code>文件控制基础样式、一个<code>navigation.css</code>文件控制两个网页的导航栏样式、一个<code>movie_card.css</code>文件控制电影卡片的样式，而主页和详情页主要的 css 样式文件仅控制其整体布局和其余不重复的元素。</p>
<p>对于 js 代码也是同样的道理，js 是对项目业务逻辑与展示逻辑的实现，这两部分工作如果能做到低耦合会大大增添代码的可读性、便于维护。</p>
<p>同样以思沃影院这个项目为例，在最初的设计时我们将 js 部分划分成了数据处理、底层服务、业务逻辑、和页面渲染这四个部分，因此我们写了 4 个 js 文件来分别实现各部分的功能，实际实现的过程中我们也发现这四个部分实际上的耦合程度是非常低的，在业务逻辑部分分别调用其他部分相关方法即可实现整体的功能。而数据处理、底层服务、和页面渲染这几部分的方法也是可以在主页的业务逻辑和详情页的业务逻辑里复用的。</p>
<h2 id="类的单一职责原则"><a href="#类的单一职责原则" class="headerlink" title="类的单一职责原则"></a>类的单一职责原则</h2><p>引用一个例子，比如一个创建一个手机类，需要它具有拨通电话、通话、结束通话三个方法，那直观的写法当然是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  dial(phoneNuber) &#123;&#125;</span><br><span class="line">  chat() &#123;&#125;</span><br><span class="line">  hangUp() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法的问题在于将建立通信、数据传送这两件事混在了一起，因此可能更好的做法是分成两个类来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">  dial(phoneNumber) &#123;&#125;</span><br><span class="line">  hangUp() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTransfer</span> </span>&#123;</span><br><span class="line">  chat() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写思沃影院时我们虽然没有使用到面向对象的思想，但是如果现在让我来重构我的代码的话，我会考虑这么划分：</p>
<ul>
<li>一个<code>Load</code>类用于加载数据</li>
<li>一个<code>CallApi</code>类，包含调用不同 api 的方法</li>
<li>一个<code>Search</code>类，包含根据不同分类、或关键词等信息筛选电影的方法</li>
</ul>
<h2 id="方法的单一职责原则"><a href="#方法的单一职责原则" class="headerlink" title="方法的单一职责原则"></a>方法的单一职责原则</h2><p>这个说起来就比较简单了，比如在思沃影院项目的<code>view.js</code>中我们写了很多方法，比如</p>
<ul>
<li><p><code>renderGuideItemActive()</code></p>
</li>
<li><p><code>renderMovieCard()</code></p>
</li>
<li><p><code>renderMovieDetials()</code></p>
</li>
<li><p><code>renderMovieComments()</code></p>
<p>…</p>
</li>
</ul>
<p>每个方法只负责页面一个特定元素的渲染、互不影响，当页面元素结构发生改变时，也只需要修改对应元素的渲染方法。</p>
<p>遵循这样的原则使我们在开发的时候无论是面对自己还是小伙伴写的代码都可以非常快速的定位和修复 bug，对提高开发效率也是非常有帮助的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么就总结一下单一职责原则的好处：</p>
<ul>
<li>简化的代码的复杂度</li>
<li>提高了代码的可读性</li>
<li>提高了代码的可维护性</li>
<li>降低了变更的风险</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JDK、JRE、JVM之间的关系</title>
    <url>/2019/01/02/JDK%E3%80%81JRE%E3%80%81JVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>…</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development Kit 是用于开发 Java 应用程序的软件开发工具，包括了 Java 运行时的环境（JRE）、解释器（Java）、编译器（javac）、Java 归档（jar ——一种软件包文件格式）、文档生成器（Javadoc）等工具。</p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Enviroment 提供 Java 应用程序执行时所需的环境，由 Java 虚拟机（JVM）、核心类、支持文件组成。</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java Virtual Machine（Java 虚拟机）有三层含义，分别是：</p>
<ul>
<li>JVM 规范要求</li>
<li>满足 JVM 规范要求的一种具体实现（一种计算机程序）</li>
<li>一个 JVM 运行实例，在命令提示符下编写 Java 命令以运行 Java 类时，都会创建一个 JVM 实例。</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>JDK = JRE + 开发工具</p>
<p>JRE = JVM + 类库</p>
<p><img src="https://cdn2.howtodoinjava.com/wp-content/uploads/2018/05/JDK-JRE-JVM.png" alt=""></p>
<h3 id="JDK-与-JRE-之间的交互"><a href="#JDK-与-JRE-之间的交互" class="headerlink" title="JDK 与 JRE 之间的交互"></a>JDK 与 JRE 之间的交互</h3><ul>
<li>首先 JDK 中的编译器（javac）对代码进行编译——存储在<code>.java</code>文件中的源代码被编译成字节码存储在<code>.class</code>文件中</li>
<li>运行过程发生在 JRE 中：</li>
</ul>
<ol>
<li>Class Loader 加载执行程序所需的全部类</li>
<li>Byte Code Verifier 验证代码的格式和合法性</li>
<li>Interpreter 加载并执行字节码</li>
</ol>
<p><img src="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/JRE_JDK_JVM_2.jpg" alt="上述操作之间的关系"></p>
<p><img src="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/JRE_JDK_JVM_4.jpg" alt=""></p>
<h3 id="JVM-的工作方式"><a href="#JVM-的工作方式" class="headerlink" title="JVM 的工作方式"></a>JVM 的工作方式</h3><p>Java 程序运行时 JVM 是 JRE 的一个实例，也就是 runtime interpreter。它执行的是<code>.class</code>文件，它会将字节码翻译为平台可以执行的机器码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 程序的开发过程为：</p>
<ul>
<li>我们利用 JDK （调用 Java API）编写出 Java 源代码，存储于 <code>.java</code> 文件中</li>
<li>JDK 中的编译器 javac 将 Java 源代码编译成 Java 字节码，存储于 <code>.class</code> 文件中</li>
<li>JRE 加载、验证、执行 Java 字节码</li>
<li>JVM 将字节码解析为机器码并映射到 CPU 指令集或 OS 的系统调用。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML本地存储</title>
    <url>/2018/12/27/HTML%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>本地存储有两类存储对象：</p>
<ul>
<li><code>window.localStorage</code>：用于存储没有截至日期的数据</li>
<li><code>window.sessionStroage</code>：针对一个 session 来存储数据（当关闭浏览器标签页时数据会丢失）</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>Storage.length</code>：返回存储对象中保存的数据项的个数</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>Storage.key([number])</code>：返回第[number]项的键名</li>
<li><code>Storage.getItem([key])</code>：返回对应的值</li>
<li><code>Storage.setItem([key], [value])</code>：设置一个新的存储项，或更改现有存储项的值</li>
<li><code>Storage.removeItem([key])</code>：删除一个存储项</li>
<li><code>Storage.clear()</code>：清空全部存储项</li>
</ul>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-JSON</title>
    <url>/2018/12/21/JavaScript-JSON/</url>
    <content><![CDATA[<p>JSON（JavaScript Object Notation）是一种 <strong>轻量级数据交换格式</strong>，用来序列化对象、数组、数值、字符串、布尔值和 <code>null</code>。</p>
<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>JSON 是纯文本</li>
<li>JSON 具有“自我描述性”（人类可读）</li>
<li>JSON 具有层级结构（值中存在值）</li>
<li>JSON 可通过 JavaScript 进行解析</li>
<li>JSON 数据可使用 AJAX 进行传输</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON 是键值对的集合，其基本形式为：</p>
<ul>
<li>数据在名称/值对中</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key1"</span>: <span class="string">"value1"</span>,</span><br><span class="line">  <span class="attr">"key2"</span>: <span class="string">"value2"</span>,</span><br><span class="line">  <span class="attr">"key3"</span>: <span class="string">"value3"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注：</span></span><br><span class="line"><span class="comment">1. 最后一个键值对后面没有逗号</span></span><br><span class="line"><span class="comment">2. 键和值均用 "" 括起来 */</span></span><br></pre></td></tr></table></figure>

<p>JSON 值可以是：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）</li>
<li>对象（在花括号中）</li>
<li>null</li>
</ul>
<p>是否是 JSON 字符串取决于上下文，在 string 上下文里使用带有大括号的 JavaScript 对象，那它就是 JSON 字符串，而如果在对象字面量上下文里使用的话，那它就是对象字面量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'&#123; "prop": "val" &#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是对象字面量</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123; <span class="attr">prop</span>: <span class="string">'val'</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>JSON.parse()</code>：解析 JSON 字符串并返回对应的值。</p>
</li>
<li><p><code>JSON.stringify()</code>：返回与指定值对应的 JSON 。</p>
</li>
</ul>
<h2 id="JSON-和-JavaScript-的关系"><a href="#JSON-和-JavaScript-的关系" class="headerlink" title="JSON 和 JavaScript 的关系"></a>JSON 和 JavaScript 的关系</h2><p>JSON 基于 JavaScript 语法，但 JavaScript 不是 JSON，JSON 也不是 JavaScript。</p>
<ul>
<li>JSON 最后一个键值对后面不能加逗号</li>
<li>JSON 的键和值均须用<code>&quot;&quot;</code>括起来</li>
<li>任何 JSON 文本都是有效的 JavaScript 表达式——但仅限于已实施 ECMA-262 的 JavaScript 引擎。JSON 中的字符串文字和属性键允许使用 U + 2028 LINE SEPARATOR 和 U + 2029 PARAGRAPH SEPARATOR，但在尚未实施 ECMA-262 的引擎中，会报语法错误。</li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Object</title>
    <url>/2018/12/17/JavaScript-Object/</url>
    <content><![CDATA[<p>由一系列 <strong>键值对</strong> 组成的变量。其基本形式为：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  key1: value1,</span><br><span class="line">  key2: value2,</span><br><span class="line">  key3: value3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>键值对的值可以是任何数据类型，包括：number, string, array, boolean, object, function 等。这些键值对称为对象的 <strong>属性</strong>，其中 function 也称为对象的 <strong>方法</strong>。对象的名字称为 <strong>命名空间</strong>。</p>
<h2 id="JavaScript-中的常见对象"><a href="#JavaScript-中的常见对象" class="headerlink" title="JavaScript 中的常见对象"></a>JavaScript 中的常见对象</h2><ul>
<li><code>String</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Window</code></li>
<li><code>Document</code></li>
<li><code>Math</code></li>
<li><code>Date</code></li>
</ul>
<h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><ol>
<li><p><code>var object = {};</code></p>
</li>
<li><p><code>var object = new Object;</code></p>
</li>
<li><p>使用自定义构造函数创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructorFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> constructorFunction();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>var object = Object.create(protoObject);</code></p>
<p>即以<code>protoObject</code>为原型创建一个新对象<code>object</code>，<code>object</code>会继承<code>protoObject</code>的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object.__proto__; <span class="comment">// return protoObject</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>constructor</code>属性创建对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> existingObject.constructor(value1, value2, ...)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="为对象增加属性"><a href="#为对象增加属性" class="headerlink" title="为对象增加属性"></a>为对象增加属性</h2><p><code>object.key = value;</code></p>
<h2 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h2><p><code>delete object.key;</code></p>
<h2 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h2><ol>
<li>用<code>.</code>来访问对象的属性：<code>object.key</code></li>
<li>用<code>[]</code>来访问对象的属性：<code>object[&#39;key&#39;]</code></li>
</ol>
<h2 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a>this 对象</h2><p><code>this</code> 指代的是当前代码行的上下文。</p>
<blockquote>
<p>The <code>this</code> keyword refers to the current object the code is being written inside.</p>
<p>It will always ensure that the correct values are used when a member’s context changes.</p>
</blockquote>
<h2 id="面向对象编程（Object-oriented-programming）"><a href="#面向对象编程（Object-oriented-programming）" class="headerlink" title="面向对象编程（Object-oriented programming）"></a>面向对象编程（Object-oriented programming）</h2><blockquote>
<p>The basic idea of OOP is that we use objects to model real world things that we want to represent inside our programs, and/or provide a simple way to access functionality that would otherwise be hard or impossible to make use of.</p>
</blockquote>
<ul>
<li>抽象：创建一个简单的模型来描述一个复杂的事物</li>
<li>实例化：可以利用类的 <strong>构造函数</strong> 来将对象实例化</li>
<li>多态性：可以通过一个基类来创建很多子类，子类可以继承基类的属性</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数具有函数的形式，但不返回任何值。可以按照如下方式创建一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructorFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property1 = value1;</span><br><span class="line">  <span class="keyword">this</span>.property2 = value2;</span><br><span class="line">  <span class="keyword">this</span>.property3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用构造函数创建对象的方式为：</p>
<p><code>var object = new constructorFunction();</code></p>
<h2 id="对象原型（Object-prototype）"><a href="#对象原型（Object-prototype）" class="headerlink" title="对象原型（Object prototype）"></a>对象原型（Object prototype）</h2><p>属性和方法是在对象的构造函数的原型属性上定义的，而不是对象实例本身。</p>
<ul>
<li>对象的原型：指每个对象实例的原型</li>
<li>构造函数的原型属性：指构造函数上的属性</li>
</ul>
<p>对象会继承其原型的所有属性（_该对象并不是复制了其原型的属性，而是通过原型链访问了原型的属性_）。</p>
<p>利用 <code>__proto__</code>可以访问对象的构造函数的原型对象。</p>
<p>继承链是动态更新的，即当原型的属性被修改后，所有该原型派生出的对象实例都能访问到该修改。</p>
<h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><p>对于<code>Object</code>这个对象来说，其能够被继承的属性是定义在它的原型上的属性，即可以以<code>Object.prototype.</code>来访问的属性。这些属性是定义在<code>Object()</code>构造函数上的属性。</p>
<h3 id="构造函数的属性"><a href="#构造函数的属性" class="headerlink" title="构造函数的属性"></a>构造函数的属性</h3><p>每个构造函数都有一个原型属性，其值是一个包含<code>constructor</code>属性的 <strong>对象</strong>。该属性指向原始构造函数。</p>
<ul>
<li>由对象实例获得其构造函数：<code>object.constructor()</code></li>
<li>获得对象实例的构造函数的名称：<code>object.constructor.name</code></li>
</ul>
<p><strong>在构造函数中定义属性是比较好的方式</strong>。实际上，对象定义的一个最常见模式是 <strong>在构造函数内定义属性、在原型上定义方法</strong>。这样可以使代码更易读。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructorFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// property definitions</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义方法</span></span><br><span class="line">constructorFunction.prototype.fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line">constructorFunction.prototype.fun2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以利用已有的构造函数派生新的构造函数</p>
<ol>
<li><p>利用<code>call()</code>函数继承已有构造函数的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已有的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">originFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property1 = value1;</span><br><span class="line">    <span class="keyword">this</span>.property2 = value2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    originFunction.call(<span class="keyword">this</span>, [...arguments]);</span><br><span class="line">    <span class="keyword">this</span>.newProperty1 = newValue1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式即定义一个新的构造函数，它有一个原型属性，默认情况下它只包含对构造函数本身的引用，而不包含<code>originFunction()</code>构造函数的原型属性。</p>
</li>
<li><p>利用<code>create()</code>函数继承已有构造函数的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">newFunction.prototype = <span class="built_in">Object</span>.create(originFunction.prototype);</span><br></pre></td></tr></table></figure>

<p>通过这种方式<code>newFunction</code>构造函数将<code>originFunction</code>构造函数的原型作为了自己的原型，并继承了其所有的方法。</p>
<p>但<code>newFunction.prototype.constructor</code>现在为 <code>originFunction()</code>，因为我们将<code>newFunction.prototype</code> 指向了一个继承了<code>originFunction.prototype</code>属性的对象。</p>
<p>为了修正这一问题，需要进行如下操作，以将<code>newFunction.prototype.constructor</code>修正为<code>newFunction()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(newFunction.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: newFunction,</span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// so that it does not appear in 'for in' loop</span></span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的undefined和null</title>
    <url>/2018/12/16/JS%E4%B8%AD%E7%9A%84undefined%E5%92%8Cnull/</url>
    <content><![CDATA[<p>undefined 是 JavaScript 中的一个数据类型，表示“缺少值”，即——此变量应有值，但未定义。<br>null 也是 JavaScript 中的一个数据类型，表示一个空对象指针，指示变量未指向任何对象。</p>
<a id="more"></a>

<h2 id="1-undefined"><a href="#1-undefined" class="headerlink" title="1. undefined"></a>1. undefined</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>undefined 是 JavaScript 中的一个数据类型。</p>
<ul>
<li><p>可以将其当作全局对象的一个属性，该属性的值为<code>undefined</code>，即：<code>window.undefined: undefined</code>。</p>
</li>
<li><p>也可以将其当作一个全局变量，该变量的唯一值为<code>undefined</code>。</p>
<blockquote>
<p>从这个意义上讲，用<code>typeof</code>操作<code>undefined</code>变量会返回一个<code>&quot;undefined&quot;</code>字符串，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">'undefined'</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><code>undefined</code>是一个<strong>空值</strong>，表示“缺少值”，即——此变量应有值，但未定义。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol>
<li>变量被声明了，但未赋值，此时该变量的默认初始值为<code>undefined</code>（即访问未初始化的变量会得到<code>undefined</code>）；</li>
<li>对象中未赋值的属性或方法，此时该属性/方法的默认初始值为<code>undefined</code>（即访问未赋值/不存在的对象属性/方法会得到<code>undefined</code>）；</li>
<li>当访问不存在（超出索引）的数组元素是会得到<code>undefined</code>；</li>
<li>调用函数时未传入的参数，此时该参数的默认初始值为<code>undefined</code>；</li>
<li>当函数无返回值时，默认返回值为<code>undefined</code>。</li>
</ol>
<p>（另外，undefined 也可以作为局部变量使用，可以给其赋一个新值，如<code>var undefined = &quot;not undefined&quot;</code>。）</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p><code>undefined</code>可以用两种方式判断：</p>
<ol>
<li>标准相等操作符<code>===</code>；</li>
<li>类型判断函数<code>typeof</code>。</li>
</ol>
<p>但考虑到 undefined 可能被赋予了另外的值，采用<code>===</code>判断可能不靠谱，因此可以使用<code>void 0</code>替代<code>undefined</code>。</p>
<blockquote>
<p><code>void</code>运算符的含义是：对给定的表达式进行求值，然后返回 undefined。</p>
</blockquote>
<h2 id="2-null"><a href="#2-null" class="headerlink" title="2. null"></a>2. null</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>null 也是 JavaScript 中的一个数据类型，表示一个空对象指针，指示变量未指向任何对象。</p>
<h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p><code>null</code>是一个空值，表示“变量未指向任何对象”，此处无值。</p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><ol>
<li>当定义的变量未来会被用作保存对象时，最好将该变量初始化为<code>null</code>；</li>
<li>当变量不再需要被使用时，可将其设置为<code>null</code>来解除引用；</li>
<li>作为对象原型链的终点。</li>
</ol>
<h3 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h3><ul>
<li><p><code>null</code>只能用严格相等操作符<code>===</code>判断。而不能用类型判断函数<code>typeof</code>判断，因为：</p>
<blockquote>
<p>在 JavaScript 最初的实现中，JavaScript 中的值由一个表示类型的标签和实际数据值表示。<code>object</code>的类型标签为 0，又由于<code>null</code>代表空指针（空值针在大多数平台下值为 0x00），致使<code>null</code>的类型标签也为 0，进而使用<code>typeof null</code>会错误的返回<code>object</code>。</p>
</blockquote>
</li>
</ul>
<h2 id="3-空值与假值"><a href="#3-空值与假值" class="headerlink" title="3. 空值与假值"></a>3. 空值与假值</h2><ul>
<li><p><code>undefined</code>和<code>null</code>均为<strong>空值</strong>。</p>
</li>
<li><p>与<strong>空值</strong>相对应的概念为<strong>假值</strong>，<code>0</code>、<code>&quot;&quot;</code>、<code>false</code>均为<strong>假值</strong>，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> == <span class="literal">false</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>空值</strong>与<strong>假值</strong>在<code>if</code>语句的条件分支中均被视为<code>false</code>，但<code>空值 !== 假值</code>，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于<code>undefined</code>实际上是<code>null</code>的派生，因此有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但由于二者属于不同的数据类型，则有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-8-个处理-undefined-的-Tips"><a href="#4-8-个处理-undefined-的-Tips" class="headerlink" title="4. 8 个处理 undefined 的 Tips"></a>4. 8 个处理 undefined 的 Tips</h2><ol>
<li><p><strong>声明变量时，推荐使用<code>const</code></strong>（尤其对于只赋值一次且不再改变的变量）、<strong>其次<code>let</code>，拒绝<code>var</code></strong></p>
<ul>
<li>好处：JavaScript 语法规定<code>const</code>定义时必须赋初值，因而使用<code>const</code>可以避免意外访问到<code>undefined</code>。</li>
</ul>
</li>
<li><p><strong>将变量的声明尽可能移到使用位置之前</strong>以增强内聚</p>
<blockquote>
<p>高内聚和<a href="https://en.wikipedia.org/wiki/Loose_coupling" target="_blank" rel="noopener">低耦合</a>是设计良好的系统的特点。</p>
<p>高内聚代码的优势：</p>
<ul>
<li>专注易理解</li>
<li>可维护易重构</li>
<li>易重用</li>
<li>易测试</li>
</ul>
</blockquote>
<ul>
<li>好处：<ul>
<li>变量不会暴露为未初始化的状态，因而不会意外访问到<code>undefined</code>；</li>
<li>增强了代码的可读性；</li>
<li>更易于重构和提取为函数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用对象时首先检查属性是否存在</strong></p>
<ul>
<li>两种推荐的检查方法：<ul>
<li>使用<code>in</code>，即<code>prop in obj</code>（可用于自身的或继承的属性）；</li>
<li>使用<code>hasOwnProperty</code>，即<code>obj.hasOwnProperty(prop)</code>（可用于自身的属性）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>解构访问对象属性</strong></p>
<ul>
<li>实现：<code>const {prop = &#39;default&#39;} = object</code></li>
</ul>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring" target="_blank" rel="noopener">对象解构</a>允许将值从对象属性直接提取到变量中，并在属性不存在时设置默认值，是一种避免直接处理<code>undefined</code>的方法。</p>
</blockquote>
</li>
<li><p><strong>使用默认属性填充对象</strong></p>
<ul>
<li><p>可以将源对象的属性赋给目标对象，两种实现方法：</p>
<ul>
<li><p><code>assign</code>函数：<code>object.assign(targetObj, sourceObj1, sourceObj2, ...)</code></p>
</li>
<li><p>在对象初始化器中扩展属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceObj1 = &#123;</span><br><span class="line">    obj1Prop1: <span class="string">"default"</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sourceObj2 = &#123;</span><br><span class="line">    obj2Prop1: <span class="string">"default"</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> targetObj = &#123;</span><br><span class="line">    sourceObj1;</span><br><span class="line">    sourceObj2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>创建函数时为参数提供默认值</strong></p>
<ul>
<li><code>function fun(variable1, variable2 = &quot;default&quot;) {...}</code></li>
</ul>
</li>
<li><p><strong>不要依赖<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-automatic-semicolon-insertion" target="_blank" rel="noopener">自动分号插入</a>(ASI)机制</strong></p>
<ul>
<li>下列语句必须自动插入分号：<ul>
<li>空语句</li>
<li><code>let</code>、<code>const</code>、<code>var</code>、<code>import</code>、<code>export</code>的声明语句</li>
<li>表达式</li>
<li><code>debugger;</code></li>
<li><code>continue;</code></li>
<li><code>break;</code></li>
<li><code>throw</code>语句</li>
<li><code>return</code>语句</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>避免使用稀疏数组</strong></p>
<ul>
<li>访问稀疏数组的空隙时会得到<code>undefined</code>。</li>
</ul>
</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><p><a href="https://juejin.im/post/5aa4f7cc518825557e780256" target="_blank" rel="noopener">JavaScript 深入理解之 undefined 与 null</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">undefined 与 null 的区别</a></p>
</li>
<li><p><a href="https://my.oschina.net/friendship/blog/644352" target="_blank" rel="noopener">Javascript 中的 false,零值,null,undefined 和空字符串对象</a></p>
</li>
<li><p><a href="https://futu.im/posts/2017-05-20-7-tips-to-handle-undefined-in-JavaScript/" target="_blank" rel="noopener">【译】7 个处理 javascript 的<code>undefined</code>的 tips</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax请求中的回调</title>
    <url>/2018/12/13/Ajax%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<ol>
<li><p>创建 Ajax 对象（可以通过函数创建）</p>
</li>
<li><p>指定结果处理器</p>
<p><code>ajax.onreadystatechange = [函数名];</code></p>
</li>
<li><p>发送数据</p>
<p><code>ajax.open(&#39;GET&#39;/&#39;POST&#39;, [url], true);</code></p>
<p><code>ajax.setRequestHeader([报头], [值])</code></p>
<p><code>ajax.send([data]);</code></p>
</li>
<li><p>中止请求</p>
<p><code>ajax.abort();</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的数据类型</title>
    <url>/2018/12/08/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>JavaScript 是一种弱类型语言，在 JavaScript 中一共有 7 种数据类型，分别是：</p>
<a id="more"></a>

<ul>
<li>原始数据类型（6 种）：<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Null</li>
<li>Undefined</li>
<li>Symbol</li>
</ul>
</li>
<li>自定义数据类型（1 种）：<ul>
<li>Object</li>
</ul>
</li>
</ul>
<p>除 Object 外，所有数据类型的原始值是不会改变的（无论进行了何种操作）。</p>
<hr>
<h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><ul>
<li><p>取值：<code>true</code>和<code>false</code></p>
</li>
<li><p>获得方法：</p>
<ol>
<li>直接定义</li>
<li>布尔运算（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）</li>
<li>比较运算（<code>&gt;</code>、<code>&lt;</code>、<code>===</code>）</li>
</ol>
</li>
<li><p>用途：常用于<strong>判断</strong>语句中。</p>
</li>
</ul>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript 不区分整数与浮点数。</p>
<ul>
<li><p>格式：双精度 64 位二进制格式</p>
<blockquote>
<p>双精度浮点数：使用 64 位（8 字节）存储一个浮点数，范围为：$${[2.23^{-308}, 1.79^{308}]}$$。</p>
</blockquote>
</li>
<li><p>取值：$$[-2^{63}+1, 2^{63}-1]$$、<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code></p>
</li>
<li><p>用途：可做四则运算。</p>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>格式：16 位无符号整数值，用单引号<code>&#39; &#39;</code>和双引号<code>&quot; &quot;</code>标记。</li>
<li>字符串创建之后不可修改，但是可以进行截取字串<code>String.substr()</code>、拼接<code>String.contact()</code>等操作。</li>
</ul>
<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><ul>
<li>含义：空。</li>
<li><code>null</code>不等于<code>0</code>或<code>&quot; &quot;</code>。</li>
</ul>
<h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><ul>
<li>含义：未定义。</li>
<li>未赋值的变量会具有一个<code>undefined</code>的默认初值。</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li>性质：唯一且不可修改。</li>
<li>用途：常用于 Object 的健的值，类似于 C 语言中的枚举类型。</li>
</ul>
<hr>
<h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li>定义：内存中可被标识符引用的一块区域；是一组属性的集合。</li>
<li>属性：<ul>
<li>数据属性：由多个 <strong>键-值</strong> 对表示，其中 <strong>键</strong> 为<code>String</code>类型或<code>Symbol</code>类型，<strong>值</strong> 可为任意数据类型。<ul>
<li>特性：<code>Value</code>、<code>Writable</code>、<code>Enumberable</code>、<code>Configurable</code></li>
</ul>
</li>
<li>访问器属性：<ul>
<li>特性：<code>Get</code>、<code>Set</code>、<code>Enumberable</code>、<code>Configurable</code></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS中实现块级元素水平居中的N种方法</title>
    <url>/2018/12/05/CSS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最近写作业的时候遇到这么一道题：</p>
<blockquote>
<p>网页由 box1、box2、box3、box4 四个盒子组成，请实现如下效果：</p>
<ul>
<li><p>1、2、3 号盒子在一行；</p>
</li>
<li><p>4 号盒子在 2 号盒子的正下方。</p>
</li>
</ul>
</blockquote>
<p>最简单的想法是四个盒子均用绝对定位，但是这种实现方法代码量大、需要计算每个盒子的位置、不灵活（如果盒子的大小改变了难以修改）。</p>
<p>另一种想法是，三个盒子排在一行可以用 float 实现，第四个盒子用绝对定位，但是依然存在上述问题。</p>
<p>因此如果能让这些盒子自己在页面居中，那无论盒子的尺寸和数目如何改变均可轻松实现想要的效果了。</p>
<p>学习了一下网上大牛们给出的方法，发现块级元素的水平居中可以通过 N 种方式实现！</p>
<a id="more"></a>

<h2 id="1-利用-margin-left-amp-right-auto-实现元素居中"><a href="#1-利用-margin-left-amp-right-auto-实现元素居中" class="headerlink" title="1. 利用 margin-left&amp;right=auto 实现元素居中"></a>1. 利用 margin-left&amp;right=auto 实现元素居中</h2><p>对于单个块级元素的水平居中可以通过将<code>margin-left</code>和<code>margin-left</code>设置为<code>auto</code>来实现。</p>
<p>以一个 box 为例，CSS 部分具体代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx6vbl7962j211y0he3yf.jpg" alt=""></p>
<p><strong>注意</strong>：该方法需要元素的宽度已知。</p>
<p>另外，如果需要水平居中多个块级元素，就要使用另外的方法了。</p>
<h2 id="2-利用-inline-block-实现元素居中"><a href="#2-利用-inline-block-实现元素居中" class="headerlink" title="2. 利用 inline-block 实现元素居中"></a>2. 利用 inline-block 实现元素居中</h2><p>将需要居中的块级元素的<code>display</code>属性设置为<code>inline-block</code>，并将其<strong>父元素</strong>的<code>text-align</code>属性设置为<code>center</code>即可实现多个块级元素的水平居中。</p>
<p>这里用到了<strong>行级格式化上下文（IFC）</strong>的概念。这种方法实际上是通过<code>inline-block</code>将三个 box 组成一个整体，此时<code>&lt;body&gt;</code>作为一个行盒可以通过<code>text-align</code>属性设置其内部元素的水平分布。</p>
<p>以三个 box 为例，HTML 部分代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>box1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>box2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>box3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 部分代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx6vikt5jej211y0he0so.jpg" alt=""></p>
<h2 id="3-利用-fit-content-实现元素居中"><a href="#3-利用-fit-content-实现元素居中" class="headerlink" title="3. 利用 fit-content 实现元素居中"></a>3. 利用 fit-content 实现元素居中</h2><p>该方法需要将 box 块设置为浮动布局（<code>float</code>），并将其<strong>父元素</strong>的宽度设定为自适应（<code>width:fit-content</code>），再结合方法一即可实现效果。</p>
<p>仍以上述三个 box 为例，CSS 部分具体代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx6vpc3v0jj211y0he0so.jpg" alt=""></p>
<h2 id="4-利用-float-relative-实现元素水平居中"><a href="#4-利用-float-relative-实现元素水平居中" class="headerlink" title="4. 利用 float+relative 实现元素水平居中"></a>4. 利用 float+relative 实现元素水平居中</h2><p>这种方式分为两步：</p>
<ol>
<li>将需要居中的块级元素设置为<code>float</code>布局，采用相对定位方式（<code>position:relative</code>)，并相对现在的位置<strong>向右（或向左）</strong>移动 50%；</li>
<li>将需要居中的块级元素的<strong>父元素</strong>设置为<code>float</code>布局，采用相对定位方式（<code>position:relative</code>)，并相对现在的位置<strong>向左（即其子元素移动的反方向）</strong>移动 50%。</li>
</ol>
<p>仍以上述三个 box 为例，CSS 部分具体代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>; <span class="comment">/*一定要与子元素移动方向相反*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx7bl7zoi6j211y0hewef.jpg" alt=""></p>
<h2 id="5-利用-float-absolute-实现元素居中"><a href="#5-利用-float-absolute-实现元素居中" class="headerlink" title="5. 利用 float+absolute 实现元素居中"></a>5. 利用 float+absolute 实现元素居中</h2><p>这种方式也分两步实现：</p>
<ul>
<li><p>第一步与方法四（float+relative）相同；</p>
</li>
<li><p>第二步中，需要居中的块级元素的<strong>父元素</strong>应采用绝对定位方式（<code>position:absolute</code>）、向其子元素移动的反方向移动 50%，并将文本对齐方式设置为居中（<code>text-align: center</code>）。</p>
</li>
</ul>
<p>以上述三个 box 为例，CSS 部分具体代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*这里与方法四不同*/</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>; <span class="comment">/*一定要与子元素移动方向相反*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx7bquv55aj211y0hewef.jpg" alt=""></p>
<h2 id="6-利用-flex-实现元素居中"><a href="#6-利用-flex-实现元素居中" class="headerlink" title="6. 利用 flex 实现元素居中"></a>6. 利用 flex 实现元素居中</h2><p>对于需要所有元素均在一排并且居中的情况，<code>flex</code>非常好用。只用将需要居中的块级元素的<strong>父元素</strong>的<code>display</code>属性设置为<code>flex</code>，<code>justify-content</code>属性设置为<code>center</code>即可。</p>
<p>以上述三个 box 为例，CSS 部分具体代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx7c1acdz7j211y0he0so.jpg" alt=""></p>
<h2 id="7-使用伪元素模拟-float-center-效果"><a href="#7-使用伪元素模拟-float-center-效果" class="headerlink" title="7. 使用伪元素模拟 float:center 效果"></a>7. 使用伪元素模拟 float:center 效果</h2><p>最后一种方法比较复杂但是可以实现文字环绕图片的效果（对于分栏排版的段落很有效）。</p>
<p>（实际上对于单栏文字环绕图片的效果通过设置图片的<code>float</code>属性即可实现，因此思考一下也很容易将这种方法拓展到多栏文字上）</p>
<p>目前 CSS 中没有<code>float:center</code>这种效果，但是可以利用伪元素进行模拟。该方法分为两步：</p>
<ol>
<li>使用伪元素<code>:before</code>分别在多栏文字上用<strong>空内容占位</strong>，并通过设置不同的<code>float</code>方向使段落的文字重新布局，产生环绕的效果。(<strong>注意</strong>：占位符的大小不能小于所插入图片的大小。)</li>
<li>采用绝对定位将需要插入的图片移动到占位符处。</li>
</ol>
<p>举一个例子看具体实现。</p>
<p>HTML 部分代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"leftText"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      第一栏...（此处省略内容）</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"rightText"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      第二栏...（此处省略内容）</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">".\我是一张图片（大小为：160*160px）.png"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 部分代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#leftText</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightText</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*两栏内容需要两个占位符，以使图片位于两栏内容中间*/</span></span><br><span class="line"><span class="selector-id">#leftText</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#rightText</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>; <span class="comment">/*以空内容占位*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">102px</span>; <span class="comment">/*宽度大于图片宽度的一半*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">180px</span>; <span class="comment">/*高度大于图片高度*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#leftText</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right; <span class="comment">/*第一栏占位符右浮动*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightText</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left; <span class="comment">/*第一栏占位符左浮动*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*用绝对定位的方式调整图片的位置*/</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">44%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: -<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx7dvs7nw2j211y0hewid.jpg" alt=""></p>
<p>这种方法虽然步骤略复杂，但是效果还是蛮好的。</p>
<h2 id="回到最初的问题"><a href="#回到最初的问题" class="headerlink" title="回到最初的问题"></a>回到最初的问题</h2><p>那对于开头的作业比较好的实现方式是什么呢？</p>
<p>对于这道题，我目前觉得最好的方式是<code>inline-block</code>。</p>
<p>可以看一下具体实现。</p>
<p>HTML 部分代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box123"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>box1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>box2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box3"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>box3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>box4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 部分代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box1</span>,</span><br><span class="line"><span class="selector-id">#box2</span>,</span><br><span class="line"><span class="selector-id">#box3</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box4</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果为：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fx7e8zvzi7j211y0he749.jpg" alt=""></p>
<hr>
<p>参考文章：</p>
<ul>
<li><p><a href="https://www.w3cplus.com/css/elements-horizontally-center-with-css.html" target="_blank" rel="noopener">六种实现元素水平居中的方法</a></p>
</li>
<li><p><a href="https://www.w3cplus.com/css/float-center.html" target="_blank" rel="noopener">使用 CSS 伪元素模拟 float:center 效果</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的Math对象</title>
    <url>/2018/12/01/JavaScript%E4%B8%AD%E7%9A%84Math%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><code>Math</code>是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。</p>
<a id="more"></a>

<h2 id="Math-的属性"><a href="#Math-的属性" class="headerlink" title="Math 的属性"></a>Math 的属性</h2><ul>
<li><code>Math.E</code>欧拉常数，也是自然对数的底数, 约等于 2.718.</li>
<li><code>Math.LN2</code>2 的自然对数, 约等于 0.693.</li>
<li><code>Math.LN10</code>10 的自然对数, 约等于 2.303.</li>
<li><code>Math.LOG2E</code>以 2 为底 E 的对数, 约等于 1.443.</li>
<li><code>Math.LOG10E</code>以 10 为底 E 的对数, 约等于 0.434.</li>
<li><code>Math.PI</code>圆周率，一个圆的周长和直径之比，约等于 3.14159.</li>
<li><code>Math.SQRT1_2</code>1/2 的平方根, 约等于 0.707.</li>
<li><code>Math.SQRT2</code>2 的平方根,约等于 1.414.</li>
</ul>
<h2 id="Math-的方法"><a href="#Math-的方法" class="headerlink" title="Math 的方法"></a>Math 的方法</h2><ul>
<li><code>Math.abs()</code>计算绝对值</li>
<li><code>Math.sin()</code>、<code>Math.cos()</code>、<code>Math.tan()</code>、<code>Math.asin()</code>、<code>Math.acos()</code>、<code>Math.atan()</code>各种三角函数</li>
<li><code>Math.sqrt()</code>、<code>Math.cbrt()</code>计算平方根、立方根</li>
<li><code>Math.ceil()</code>、<code>Math.floor()</code>向上、向下取整</li>
<li><code>Math.exp()</code>计算$e^x$</li>
<li><code>Math.log()</code>、<code>Math.log10()</code>、<code>Math.log()</code>计算$ln$、$lg$、$log_2$</li>
<li><code>Math.max()</code>、<code>Math.min()</code>计算最大值、最小值</li>
<li><code>Math.pow(x,y)</code>计算$x^y$</li>
<li><code>Math.random()</code>返回 0 到 1 间的伪随机数</li>
<li><code>Math.round()</code>四舍五入取整</li>
<li><code>Math.trunc()</code>返回整数部分</li>
<li><code>Math.sign()</code>判断正负数</li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>自增运算符</title>
    <url>/2018/11/30/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<ul>
<li>前自增运算符：先自增再做其他操作；</li>
<li>后自增运算符：先做其他操作再自增。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a, b, c &#x3D; 0;</span><br><span class="line">a &#x3D; c++; &#x2F;&#x2F; a &#x3D; 0;</span><br><span class="line">b &#x3D; ++c; &#x2F;&#x2F; b &#x3D; 2;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Chrome DevTools进行CSS样式调试</title>
    <url>/2018/11/23/%E9%80%9A%E8%BF%87Chrome-DevTools%E8%BF%9B%E8%A1%8CCSS%E6%A0%B7%E5%BC%8F%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>可以按照<strong>评估和快速修复</strong>、<strong>还原和重现</strong>、<strong>定位根源和修复</strong>这样的步骤进行调试。</p>
<a id="more"></a>

<h2 id="1-评估和快速修复"><a href="#1-评估和快速修复" class="headerlink" title="1. 评估和快速修复"></a>1. 评估和快速修复</h2><p>首先针对能够快速解决的错误进行修复。</p>
<p>这一步的关键是要 <code>深刻理解CSS各种属性的内涵和效果</code>，以避免当页面样式不符合预期时无法定位问题。</p>
<h2 id="2-还原和重现"><a href="#2-还原和重现" class="headerlink" title="2. 还原和重现"></a>2. 还原和重现</h2><p>初步定位问题后需要对问题进行复现。</p>
<ul>
<li>方法：提出相关的 HTML 和 CSS 代码。</li>
<li>关键：精简代码，找出关键点。</li>
</ul>
<p><strong>对于 CSS 代码</strong>：</p>
<ol>
<li>逐步增加/删除 CSS 以暴露问题；</li>
<li>利用<a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener">CSS Validator</a>进行检查。</li>
</ol>
<p><strong>对于 HTML 代码</strong>：</p>
<ul>
<li>利用<a href="https://validator.w3.org/" target="_blank" rel="noopener">W3C Validator</a>检查规范性。</li>
<li>将所有元素改成<code>div</code>或者<code>span</code>类型，将所有选择器改为类选择器，以排除浏览器引入意外样式的可能性。</li>
</ul>
<h2 id="3-定位根源并修复"><a href="#3-定位根源并修复" class="headerlink" title="3. 定位根源并修复"></a>3. 定位根源并修复</h2><ul>
<li>如果是浏览器引入的意外样式，则想办法覆盖；</li>
<li>若不是，更换浏览器尝试是否会发生同样的现象，以确定是否是浏览器类型、浏览器版本等因素的原因，并通过 bug 追踪寻找解决方案；</li>
<li>重点关注<code>computed styles</code>查看自己编写的 CSS 代码中哪些样式生效了、哪些被屏蔽了。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>CSS中字体相关知识点总结</title>
    <url>/2018/11/22/CSS%E4%B8%AD%E5%AD%97%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>CSS 中物种通用字体系列</li>
<li>怎样设置多个字体</li>
<li>px、em、rem 的不同</li>
</ol>
<a id="more"></a>

<h2 id="1-CSS-中物种通用字体系列"><a href="#1-CSS-中物种通用字体系列" class="headerlink" title="1. CSS 中物种通用字体系列"></a>1. CSS 中物种通用字体系列</h2><ul>
<li>衬线体（Serif）：Georgia、宋体</li>
<li>无衬线体（Sans-Serif）：Arial、Helvetica、黑体、微软雅黑</li>
<li>手写体（Cursive）：Caflisch Script、楷体</li>
<li>梦幻体（Fantasy）：Comic Sans MS、Papyrus、Zapfino</li>
<li>等宽字体（Monospace）：Consolas、Courier、中文字体</li>
</ul>
<h2 id="2-怎样设置多个字体"><a href="#2-怎样设置多个字体" class="headerlink" title="2. 怎样设置多个字体"></a>2. 怎样设置多个字体</h2><p><code>font-family:字体1, 字体2, 字体3, ..., 通用字体系列名</code></p>
<p>设置多个字体的写法如上所示，需要注意的是：</p>
<ul>
<li>按照选用优先级声明期望使用的字体名称，用逗号分隔；</li>
<li>若段落中既有英文也有中文，则先声明英文期望字体再声明中文期望字体，避免使用中文字体样式显示英文；</li>
<li>字体名称超过一个单词/字符时应用双引号括起来，如：<code>&quot;Times New Roman&quot;</code>、<code>&quot;宋体&quot;</code>；</li>
<li>在所有字体最后写一个通用字体类名称，以保证能按照期望样式显示而非浏览器默认样式。</li>
</ul>
<h2 id="3-px、em、rem-的不同"><a href="#3-px、em、rem-的不同" class="headerlink" title="3. px、em、rem 的不同"></a>3. px、em、rem 的不同</h2><ul>
<li>px：绝对单位，1px 对应一个像素点；</li>
<li>em：相对单位，1em 对应当前字体的大小；</li>
<li>rem：相对单位，1rem 对应 html 元素的大小。</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Git部分指令理解</title>
    <url>/2018/11/21/Git%E9%83%A8%E5%88%86%E6%8C%87%E4%BB%A4%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global&#x2F;local</span><br><span class="line">git revert&#x2F;reset&#x2F;reflog</span><br><span class="line">git checkout --filename&#x2F;branch</span><br><span class="line">git pull origin &#x2F; git pull --rebase &#x2F; git fetch</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="git-config-–global-local"><a href="#git-config-–global-local" class="headerlink" title="git config –global/local"></a>git config –global/local</h3><p>git 的配置数据分 local 级、global 级、system 级三类。</p>
<ul>
<li>local 级：位于当前仓库下，仅对当前仓库有效；</li>
<li>global 级：位于系统用户目录下，对当前用户的所有仓库有效；</li>
<li>system 级：位于 git 的安装目录下，对所有用户的所有仓库有效。</li>
</ul>
<hr>
<h3 id="git-revert-reset-reflog"><a href="#git-revert-reset-reflog" class="headerlink" title="git revert/reset/reflog"></a>git revert/reset/reflog</h3><ul>
<li><code>git revert</code>：撤销某次操作，所有的提交均被保留，并用一个逆向的提交修改当前内容，实现回滚。revert 之后 head 前进一格。</li>
<li><code>git reset</code>：撤销某次提交，并将该次提交的内容退回暂存区。reset 之后 head 后退一格。</li>
<li><code>git reflog</code>：查看所有分支的所有操作记录（包含被删除的 commit）。</li>
</ul>
<hr>
<h3 id="git-checkout-–filename-branch"><a href="#git-checkout-–filename-branch" class="headerlink" title="git checkout –filename/branch"></a>git checkout –filename/branch</h3><ul>
<li><code>git checkout --filename</code>：把该文件在工作区的修改撤销到最近一次的<code>add</code>或<code>commit</code>操作时的内容。</li>
<li><code>git checkout --branch</code>：在分支间进行切换。</li>
</ul>
<hr>
<h3 id="git-pull-origin-git-pull-–rebase-git-fetch"><a href="#git-pull-origin-git-pull-–rebase-git-fetch" class="headerlink" title="git pull origin / git pull –rebase / git fetch"></a>git pull origin / git pull –rebase / git fetch</h3><ul>
<li><code>git pull origin</code>：取回远程分支并与本地分支进行合并。</li>
<li><code>git pull --rebase</code>：当远程分支删除某个分支时，使用该命令可在合并时将本地对应的分支删除。</li>
<li><code>git fetch</code>：取回远程分支，但不与本地分支进行合并。</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法总结</title>
    <url>/2018/11/04/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>看了很多 Markdown 简明教程，感觉使用 Markdown 最大的优势就是<strong>可以完全使用键盘完成排版</strong>。但是这个听起来没有什么优势啊，那想象一下传统的排版方式，比如我们想给一段文字加粗，那就需要选择段落、右键、点击加粗按钮。但是在 Markdown 里只需要在这段文字的首尾各加上两个 <code>**</code> 号就可以了，是不是灰常方便！对于更负责的排版操作，比如标题、列表来说就更是 so easy 啦！</p>
<p>So，为了练习&amp;记忆，自己来整理一下</p>
<a id="more"></a>

<hr>
<h3 id="首先我们需要一个标题"><a href="#首先我们需要一个标题" class="headerlink" title="首先我们需要一个标题"></a>首先我们需要一个标题</h3><p>标题是分隔文章层次的好方法，因此 Markdown 也为我们提供了 6 级标题以供使用，而且用法非常简单，只要在文字前加上 <code>#</code> 就可以了。</p>
<p>标题的层级与 <code>#</code> 的数目对应。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvce2plrbj20ne05mt8r.jpg" alt=""></p>
<p>（一个温馨提示：<code>#</code> 与文字间需要加上一个<strong>空格</strong>~）</p>
<hr>
<h3 id="文字的加粗与斜体"><a href="#文字的加粗与斜体" class="headerlink" title="文字的加粗与斜体"></a>文字的加粗与斜体</h3><p>写文章总是要划重点的，因此加粗和斜体必不可少。</p>
<ul>
<li><p>加粗：文字前后各加两个 <code>**</code> 号</p>
</li>
<li><p>斜体：文字前后各加一个 <code>*</code> 号或一个<code>_</code></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvcg79hgxj20n503wglk.jpg" alt=""></p>
</li>
</ul>
<hr>
<h3 id="我是愉快的分割线"><a href="#我是愉快的分割线" class="headerlink" title="我是愉快的分割线"></a>我是愉快的分割线</h3><p>有时候我们需要利用分割线划分文字的内容，在 Markdown 里可以输入<code>---</code>再回车，就会出现一条愉快的分割线啦！</p>
<hr>
<h3 id="加入一个列表"><a href="#加入一个列表" class="headerlink" title="加入一个列表"></a>加入一个列表</h3><p>为了清楚的记录关键点，我们常常使用列表。在 Markdown 里，无序列表直接用<code>*</code>或者<code>-</code>标记就好。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvc0jp4ejj20lq067dfx.jpg" alt=""></p>
<p>对于有序列表直接敲数字编号。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvc97iyomj20n301yjra.jpg" alt=""></p>
<hr>
<h3 id="插入链接和图片"><a href="#插入链接和图片" class="headerlink" title="插入链接和图片"></a>插入链接和图片</h3><p>为了增加文章的可读性或者进行一些补充说明时，我们往往需要插入链接和图片，插入的语法为：</p>
<ul>
<li><p>链接：<code>[需要显示的文字]（链接地址）</code></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvctfbynsj20ti013t8l.jpg" alt=""></p>
</li>
<li><p>图片：<code>![图题](图片地址)</code></p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvcwhx1ykj210n05i3z8.jpg" alt=""></p>
</li>
</ul>
<p>对于本地图片我们可以使用 <em>新浪图床</em> 等插件<a href="https://www.jianshu.com/p/03854b6246a4" target="_blank" rel="noopener">快速将获得图片的 Markdown 链接</a>。</p>
<p>（一个温馨提示：插入图片时不要漏掉 <code>!</code> 哦~）</p>
<hr>
<h3 id="引用好词好句"><a href="#引用好词好句" class="headerlink" title="引用好词好句"></a>引用好词好句</h3><p>写文章时难免需要引用，加个<code>&quot;&quot;</code>当然是一种方式，但是看起来不够美观，更好的方式是使用 <code>&gt;</code>，即在引用的段落前加一个 <code>&gt;</code>。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvddnq9xtj20rb03o0sp.jpg" alt=""></p>
<p>这样被引用的段落会和其他段落直接有明显的区分，而且很好看！</p>
<p>（一个温馨提示：<code>&gt;</code> 与文字间需要加上一个<strong>空格</strong>~）</p>
<hr>
<h3 id="插入一段代码"><a href="#插入一段代码" class="headerlink" title="插入一段代码"></a>插入一段代码</h3><p>作为一个程序员…写技术类文档时直接插入代码比仅使用文字更直观。</p>
<ul>
<li><p>行内代码：将代码部分用<strong>反引号</strong>括起来。</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvdksgknvj20ia014dfo.jpg" alt=""></p>
</li>
</ul>
<ul>
<li><p>代码块：（难以描述，直接看图吧…）</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvdoe9x6qj20it0423yd.jpg" alt=""></p>
</li>
</ul>
<hr>
<h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><p>当然了，也许你有插入表格的需求，但是这个真的很麻烦…</p>
<p>因为需要自己把表格画出来，比如：</p>
<p><img src="http://ww1.sinaimg.cn/large/98792392ly1fwvdy7vikyj20lp0500ss.jpg" alt=""></p>
<p>画表格时常用的语法有：</p>
<ul>
<li>列用 <code>|</code> 分隔；</li>
<li>每列文字对齐方式用 <code>:</code> 调整。其中 <code>---</code> 表示左对齐、<code>:---:</code>表示居中、<code>---:</code>表示右对齐；</li>
<li>标题栏下方一行先写对齐方式，对齐方式下面再写表格内容。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>如何提问</title>
    <url>/2018/11/01/%E5%A6%82%E4%BD%95%E6%8F%90%E9%97%AE/</url>
    <content><![CDATA[<p>总结了怎么提问能帮助自己更快获得帮助</p>
<a id="more"></a>

<ol>
<li><p>提问之前：</p>
<ul>
<li>明确自己的问题；</li>
<li>尝试搜索答案（google、论坛、FAQ…）。</li>
</ul>
</li>
<li><p>准备提问时：</p>
<ul>
<li>选择合适的论坛（主题相关性）；</li>
<li>优先在论坛上发帖，不能解决时再邮件询问；</li>
<li>优先给项目邮件列表发邮件，不能解决时再询问个别人；</li>
<li>优先给使用者邮件列表发邮件，不能解决时再询问开发者；</li>
<li>提问前先观察。</li>
</ul>
</li>
<li><p>描述问题时：</p>
<ul>
<li>使用有意义且明确的标题</li>
<li>将问题描述清楚</li>
<li>简化问题；</li>
<li>描述目标而不是中间过程；</li>
<li>按时间发生顺序描述出现的症状，而不是自己的猜测；</li>
<li>描述清楚使用的硬件/系统的配置；</li>
<li>描述自己的尝试解答的过程及结果；</li>
<li>提供可重现问题的环境、精简的测试用例；</li>
<li>注意礼貌。</li>
</ul>
</li>
<li><p>问题得到解答后：</p>
<ul>
<li>回复原帖注明已解决，简述解决的方法和应避免的盲点，对帮助过自己的人提出感谢。</li>
</ul>
</li>
</ol>
<ul>
<li>核心思想：网络是一个大的互助社区，不要做伸手党、节约他人的精力、并且尽可能帮助其他可能碰到同样问题的人。</li>
</ul>
]]></content>
  </entry>
</search>
